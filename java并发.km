{"root":{"data":{"id":"97f1c71964bd","created":1557548343,"text":"java并发"},"children":[{"data":{"id":"bu091onsnds0","created":1557549017501,"text":"并发","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu76mqwe8yo0","created":1558253124389,"text":"基础知识","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu76mxine800","created":1558253138796,"text":"易混淆概念","expandState":"expand","layout":null},"children":[{"data":{"id":"bu76o8wini00","created":1558253241943,"text":"1、阻塞 非阻塞","note":"同步阻塞调用：得不到结果不返回，线程进入阻塞态等待。\n同步非阻塞调用：得不到结果不返回，线程不阻塞一直在CPU运行。\n异步阻塞调用：去到别的线程，让别的线程阻塞起来等待结果，自己不阻塞。\n异步非阻塞调用：去到别的线程，别的线程一直在运行，直到得出结果。","expandState":"expand","layout":null},"children":[{"data":{"id":"bu76osonxw80","created":1558253285004,"text":"描述的是线程状态","layout":null},"children":[]},{"data":{"id":"bu76p16bp8w0","created":1558253303486,"text":"线程阻塞状态，不占用cpu。线程挂起等待，直到条件满足","layout":null},"children":[]},{"data":{"id":"bu771b2z78g0","created":1558254265421,"text":"非阻塞 ：不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。","layout":null},"children":[]}]},{"data":{"id":"bu76oifr9140","created":1558253262697,"text":"2、同步 异步","expandState":"expand","layout":null},"children":[{"data":{"id":"bu774gm62800","created":1558254512558,"text":"不会有线程挂起的情况，cpu有可能还在处理","layout":null},"children":[]},{"data":{"id":"bu775pk81dc0","created":1558254610396,"text":"同步调用时，在没有得到结果之前，该调用就不返回","layout":null},"children":[]},{"data":{"id":"bu7762xznwg0","created":1558254639526,"text":"异步调用后，调用者不会立刻得到结果，该调用就返回了","note":"一般是使用新的线程实现不等待","layout":null},"children":[]}]},{"data":{"id":"bu76ommqors0","created":1558253271827,"text":"3、并行 并发","expandState":"expand","layout":null},"children":[{"data":{"id":"bu777n0fqzc0","created":1558254761574,"text":"并发：一个cpu，多个程序切换进行，一个时间点只有一个程序在处理器运行","layout":null},"children":[]},{"data":{"id":"bu777zmlpcw0","created":1558254789036,"text":"并行：多个cpu 同时间 各自 做自己的任务","layout":null},"children":[]}]},{"data":{"id":"bu78pxpm3f40","created":1558259016529,"text":"临界区 资源","expandState":"expand","layout":null},"children":[{"data":{"id":"bu78q3vimrk0","created":1558259029947,"text":"临界区：共享资源的访问代码块","layout":null},"children":[]},{"data":{"id":"bu78qyh7xns0","created":1558259096562,"text":"同一时间只允许一个线程执行","layout":null},"children":[]}]}]},{"data":{"id":"bu7vebkm42o0","created":1558322991860,"text":"线程状态和基本操作","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu7vfx9wan40","created":1558323117465,"text":"如何新建线程","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bu7vg2c2j280","created":1558323128480,"text":"继承Thread类","layout":null},"children":[]},{"data":{"id":"bu7vg88r6tk0","created":1558323141340,"text":"实现Runnable接口","expandState":"expand","layout":null},"children":[{"data":{"id":"bu7wngbtjw00","created":1558326528599,"text":"相对Thread优点","expandState":"expand","layout":null},"children":[{"data":{"id":"bu7wmx90b9k0","created":1558326487070,"text":"不被单继承所限制","layout":null},"children":[]},{"data":{"id":"bu7wn297f4o0","created":1558326497966,"text":"更加便于共享资源","note":"一个实现了runnable接口的类，可被放入多个线程中。再执行start\n\n共享资源指的就是一个资源多处利用","layout":null},"children":[]},{"data":{"id":"bu7wpmw20g00","created":1558326699612,"text":"线程池中不能放Thread类","layout":null},"children":[]}]}]},{"data":{"id":"bu7vggw6a4w0","created":1558323160171,"text":"实现Callable接口","expandState":"expand","layout":null},"children":[{"data":{"id":"bu7wpzlxtk00","created":1558326727298,"text":"可获取线程执行返回的结果","layout":null},"children":[]},{"data":{"id":"bu7wqbwjucg0","created":1558326754061,"text":"可以抛出异常，并在feature.get的时候捕获（该异常只影响当前线程）","layout":null},"children":[]}]}]},{"data":{"id":"bu7zogemv680","created":1558335070463,"text":"线程状态切换","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu7zr50mvmo0","created":1558335280765,"text":"New","layout":null,"note":"新创建了一个线程对象"},"children":[]},{"data":{"id":"bu7zra2c5g00","created":1558335291751,"text":"Runnable","layout":null,"note":null,"expandState":"expand"},"children":[{"data":{"id":"bu801g76orc0","created":1558336088747,"text":"ready","note":"调用了start()方法\n\n线程位于可运行线程池中，变得可运行，等待获取CPU的使用权","layout":null},"children":[]},{"data":{"id":"bu7zrmck5yg0","created":1558335318491,"text":"Running","layout":null,"note":"就绪状态的线程获取了CPU，正在执行\n"},"children":[]}]},{"data":{"id":"bu7zs01p47s0","created":1558335348309,"text":"Blocked","layout":null,"note":"表示线程阻塞于锁"},"children":[]},{"data":{"id":"bu7zs9xnl2w0","created":1558335369832,"text":"Waiting","layout":null,"note":"\n要等待被显式地唤醒，否则会处于无限期等待的状态。"},"children":[]},{"data":{"id":"bu7zsprpbhs0","created":1558335404301,"text":"Time_Waiting","layout":null,"note":"该状态不同于WAITING，它可以在指定的时间后自行返回。"},"children":[]},{"data":{"id":"bu7zwa7hdl40","created":1558335683883,"text":"Terminated/dead","note":"线程已经执行完毕","layout":null},"children":[]}]},{"data":{"id":"bu80csd7m8g0","created":1558336977238,"text":"线程基本操作","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu80dq56yiw0","created":1558337050764,"text":"Thread.sleep(long millis)","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu80dy2oifs0","created":1558337068027,"text":"当前线程调用，进入TIMED_WAITING状态，不释放锁，millis后线程自动苏醒进入就绪状态","layout":null},"children":[]}]},{"data":{"id":"bu80hzs1fe80","created":1558337385193,"text":"Thread.yield()","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu80i1uwnxc0","created":1558337389720,"text":"当前线程调用，放弃获取的CPU时间片，不释放锁，变为就绪ready状态，让OS再次选择线程","layout":null},"children":[]}]},{"data":{"id":"bu80qjn3o800","created":1558338055344,"text":"thread.join()/thread.join(long millis)","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bu80qv6qf3c0","created":1558338080475,"text":"当前线程里调用其它线程t的join方法，当前线程进入WAITING/TIMED_WAITING状态","layout":null},"children":[]},{"data":{"id":"bu80rok8tq00","created":1558338144419,"text":"当前线程不会释放锁。线程t执行完毕或者millis时间到，当前线程一般情况下进入RUNNABLE状态，也有可能进入BLOCKED状态（因为join是基于wait实现的）。","layout":null},"children":[]}]},{"data":{"id":"bu80sz4avgo0","created":1558338245764,"text":"obj.wait()","layout":null,"expandState":"expand","note":"当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。（等待队列是一个set）\n\n依靠notify()/notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。\n\n中断也会唤醒（会抛出中断异常）\n\n线程调用某对象的wait进入等待队列，并不会释放其他的锁（假如还持有其他锁的话）\n\n"},"children":[]},{"data":{"id":"bu80zdw0gnk0","created":1558338748099,"text":"obj.notify()","layout":null,"expandState":"expand","note":"唤醒在此对象监视器上等待的单个线程，选择是任意性的。\n\nnotifyAll()唤醒在此对象监视器上等待的所有线程\n\n当前线程要退出同步代码块才释放锁"},"children":[]},{"data":{"id":"bu817w0rc200","created":1558339414482,"text":"LockSupport.park()/LockSupport.parkNanos(long nanos),LockSupport.parkUntil(long deadlines)","layout":null,"expandState":"expand","note":" 1、当前线程进入WAITING/TIMED_WAITING状态。\n \n 对比wait方法,不需要获得锁就可以让线程进入WAITING/TIMED_WAITING状态。\n \n 2、需要通过LockSupport.unpark(Thread thread)唤醒。"},"children":[]},{"data":{"id":"bu82cd0y7js0","created":1558342586065,"text":"线程中断","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu82gvbb8w00","created":1558342939330,"text":"api","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu82i4b9f0o0","created":1558343037283,"text":"public void interrupt()","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu82pbzkm6g0","created":1558343602539,"text":"其他线程调用，向此线程发出中断指令","layout":null},"children":[]}]},{"data":{"id":"bu82io5ri3c0","created":1558343080486,"text":"public boolean isInterrupted()","layout":null},"children":[{"data":{"id":"bu82u3vuisg0","created":1558343976720,"text":"对应的此线程的中断标志位是否为true","layout":null},"children":[]}]},{"data":{"id":"bu82kxbi7ps0","created":1558343257152,"text":"public static boolean interrupted()","layout":null},"children":[{"data":{"id":"bu82w7x9isg0","created":1558344142242,"text":"返回中断标志位的值，并重新设置为false","layout":null},"children":[]}]}]},{"data":{"id":"bu82wq0wouw0","created":1558344181644,"text":"不同状态的线程对中断的反应","layout":null},"children":[{"data":{"id":"bu82yk7unbk0","created":1558344325731,"text":"RUNNABLE","layout":null},"children":[{"data":{"id":"bu82ym684m00","created":1558344329987,"text":"设置中断标志为true，无其他影响。可在代码中手动获取标志进行下一步操作","layout":null},"children":[]}]},{"data":{"id":"bu830byq9xs0","created":1558344464494,"text":"WAITING/TIMED_WAITING","layout":null},"children":[{"data":{"id":"bu830elk5gw0","created":1558344470229,"text":"线程抛出InterruptedException","note":"中断标志位会被清空，线程的中断标志位会由true重置为false\n\n因为线程为了处理异常已经重新处于就绪状态，而不是被设置\n\n抛出的异常catch，并做出相应的处理","layout":null},"children":[]}]},{"data":{"id":"bu833k8x9lc0","created":1558344717617,"text":"BLOCKED","layout":null},"children":[{"data":{"id":"bu835mymssg0","created":1558344880254,"text":"设置中断标志为true，无其他影响。","layout":null},"children":[]}]},{"data":{"id":"bu8360ierm00","created":1558344909748,"text":"NEW/TERMINATE","layout":null},"children":[{"data":{"id":"bu8365e9sm80","created":1558344920381,"text":"没有任何效果，中断标志位也不会被设置","layout":null},"children":[]}]}]}]}]}]}]},{"data":{"id":"butau3fhy540","created":1560499303701,"text":"synchornized","expandState":"expand","layout":null},"children":[{"data":{"id":"bu3u54ci9xc0","created":1557913209918,"text":"锁膨胀","note":"1. 线程的阻塞和唤醒需要CPU从用户态转为核心态\n\n2. 频繁阻塞和唤醒影响性能。引出锁膨胀\n  * jdk1.6优化\n\n\n3. 锁可以升级但不能降级","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu3uaxn4oxk0","created":1557913665508,"text":"偏向锁","note":null,"layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu4hskr5ivs0","created":1557979933536,"text":"对象头Mark Word 中存储线程id","layout":null},"children":[]},{"data":{"id":"bu4hstky75c0","created":1557979952751,"text":"有线程来访问，先比较线程id","priority":1,"expandState":"expand","layout":null},"children":[{"data":{"id":"bu4ht1moi0o0","created":1557979970270,"text":"如果是同一线程，获得锁。多次加锁解锁不耗性能。","priority":2,"layout":null},"children":[]},{"data":{"id":"bu4ht54ldvk0","created":1557979977884,"text":"不是同一线程，使用cas比较替换","priority":2,"layout":null},"children":[{"data":{"id":"bu4hty2v1a00","created":1557980040906,"text":"原线程已挂或者不再使用，重新偏向当前线程","layout":null},"children":[]},{"data":{"id":"bu4hu5e2mj40","created":1557980056821,"text":" 原线程需要继续持有，升级为轻量级锁","progress":9,"layout":null},"children":[]}]}]}]},{"data":{"id":"bu3ub4tlu2w0","created":1557913681137,"text":"轻量级锁","layout":null,"note":null,"expandState":"expand"},"children":[{"data":{"id":"bu4i7zynrkw0","created":1557981142104,"text":"Mark Word 中存储指针：指向栈中锁记录","note":"Displaced Mark Word：一个线程尝试获得轻量级锁，jvm会在线程所在的栈帧中创建空间，用于存储锁记录\n","layout":null},"children":[]},{"data":{"id":"bu4if7g9nog0","created":1557981706955,"text":"新线程使用 CAS 将Mark Word替换为指向锁记录的指针","priority":1,"layout":null},"children":[{"data":{"id":"bu4ifx02f6w0","created":1557981762572,"text":"成功：获取锁。自旋操作 占用cpu","layout":null,"priority":2},"children":[]},{"data":{"id":"bu4ighaxfxk0","created":1557981806764,"text":"失败：自旋尝试获取锁","layout":null,"priority":2},"children":[{"data":{"id":"bu4ihxndpmg0","created":1557981920710,"text":"自旋一定时间内获得锁","layout":null},"children":[]},{"data":{"id":"bu4iipif9280","created":1557981981360,"text":"一定时间获取不了锁，升级为重量级锁","progress":9,"layout":null},"children":[]},{"data":{"id":"bu4iixloum80","created":1557981998972,"text":"有一个在自旋，有第三个线程进来，升级为重量级锁","progress":9,"layout":null},"children":[]}]}]}]},{"data":{"id":"bu3ubbpei3c0","created":1557913696120,"text":"重量级锁（传统的锁）","layout":null},"children":[{"data":{"id":"bu4kp5unr5c0","created":1557988129333,"text":"Mark Word 中存储指针：指向moniter（操作系统互斥量）","layout":null},"children":[]},{"data":{"id":"bu4l7s7vsxk0","created":1557989588577,"text":"线程不自旋、不占用cpu。线程阻塞","layout":null},"children":[]}]}]},{"data":{"id":"bu3q3nkj0i80","created":1557901810594,"text":"Monitor监视器对象","note":null,"layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu3qndu7nxc0","created":1557903356695,"text":"1、操作系统层面概念，负责操控线程","note":"在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的\n\n_owner : 当前拥有该 ObjectMonitor 的线程\n_EntryList: 当前等待锁的集合\n_WaitSet: 调用了Object.wait()方法而进入等待状态的线程的集合，即我们上一篇一直提到的wait set\n\n\n1、维持一个代码数据区和线程队列等。\n2、保证同一时刻只有一个线程访问代码数据区\n3、监视器就是通过判断对象里锁来完成这个安全访问的功能的\n\n\n4、jvm进入和退出Monitor对象来实现方法同步和代码块同步\n\n5、代码块实现细节：\nmonitorenter和monitorexit\n\n6、方法同步细节\n无描述，但也可以使用以上指令实现","layout":null},"children":[]},{"data":{"id":"bu3qkut00000","created":1557903158534,"text":"2、每个对象或Class关联一个监视器","layout":null},"children":[]}]},{"data":{"id":"bu3qsfy8fqg0","created":1557903753112,"text":"对象结构","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu3qss7n7ao0","created":1557903779803,"text":"对象头（锁）","layout":null},"children":[{"data":{"id":"bu3syvpyb4w0","created":1557909899845,"text":" Mark Word","layout":null},"children":[{"data":{"id":"bu3u0s4c6800","created":1557912869846,"text":"运行时数据","image":"http://kityminder-img.gz.bcebos.com/763f0a67fd7fb2b8004eca865326163ea7209fa4","imageTitle":"","imageSize":{"width":200,"height":69},"note":"非固定数据结构","layout":null},"children":[]}]},{"data":{"id":"bu3tbvpy49c0","created":1557910918579,"text":"类型指针","note":" JVM通过此指针来确定对象是哪个类的实例","layout":null},"children":[]},{"data":{"id":"bu3twkpvwig0","created":1557912540278,"text":"数组长度","note":"对象是数组类型的话","layout":null},"children":[]}]},{"data":{"id":"bu3qsx9q9280","created":1557903790813,"text":"实例数据","layout":null},"children":[]},{"data":{"id":"bu3qtboo9ww0","created":1557903822191,"text":"对齐填充","note":"占位符，无特殊的含义。\n\n保证整个对象大小是8字节整数倍","layout":null},"children":[]}]}]},{"data":{"id":"bu4lg3rzsjk0","created":1557990240651,"text":"CAS机制","expandState":"expand","layout":null},"children":[{"data":{"id":"bu4lkawra800","created":1557990569633,"text":"Compare and Swap\n比较替换 ","note":"通过VAB分别记录内存地址，原值、新值\n\n当内存地址的值与原值一致，说明没修改过，则直接替换为新值B，否则一致尝试\n\n此处内存地址值泛指一个多处可修改的值\n\n\nCAS操作依赖于 现代处理器 指令集 实现。传入的四个参数\n1. 一个对象，猜测是加锁用\n2. 要修改的值\n\n3. 期望值\n4. 修改值\n\n* 一般是传入期望值、修改值即可，也有全部都传入的\n\n","layout":null},"children":[]},{"data":{"id":"bu4lkush6xs0","created":1557990612910,"text":"应用","layout":null},"children":[{"data":{"id":"bu4lookcomw0","created":1557990912814,"text":"乐观锁","layout":null},"children":[]},{"data":{"id":"bu4losz38s80","created":1557990922413,"text":"java.util.concurrent.atomic包中保证原子性的类","layout":null},"children":[]}]},{"data":{"id":"bu4lrvg7y8w0","created":1557991162895,"text":"缺点","layout":null},"children":[{"data":{"id":"bu4ls1hf0080","created":1557991176028,"text":"失败后一直尝试，占用cpu","layout":null},"children":[]},{"data":{"id":"bu4ls7wovps0","created":1557991190012,"text":"ABA问题（可加入版本号控制）","layout":null},"children":[]},{"data":{"id":"bu4lsp7qyrs0","created":1557991227686,"text":"只能保证一个变量的原子性操作，而不能保证整个代码块的原子性","layout":null},"children":[]}]}]},{"data":{"id":"bu4lx892pxk0","created":1557991582581,"text":"同步工具类","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu4lxdlyus00","created":1557991594245,"text":"闭锁 CountDownLatch","layout":null,"expandState":"expand","note":"1、基于AQS共享锁。初始传进的值就是state的值。\n\n2、countdown，每次cas自旋减去指定次数。\n重写释放锁逻辑，实际是成功后返回当前state是否等于0\n\n3、已经是0则释放锁，唤醒同步队列中等待的线程\n\n4、await方法，通过重写获取锁方法，实际上是检查state是否为0 ，不是返回负数表示获取不了锁。将线程放进同步队列。\n\n另外还提供了超时方法\nawait(long timeout, TimeUnit unit)"},"children":[{"data":{"id":"bu4mkojl38w0","created":1557993420421,"text":"用法","layout":null,"note":"1、设置资源个数 new CountDownLatch(2);\n\n2、latch.countDown();\n\n3、某线程中使用latch.await()，则需锁的资源减到0后才执行完await，继续后面逻辑\n\n4、CountDownLatch是一次性的，“闸门”开启后，无法再重复使用，如果想重复使用，应该用[CyclicBarrier]()\n\n5、执行countDown的跟执行await的是不同线程。"},"children":[]}]},{"data":{"id":"bu4m006jlhs0","created":1557991800107,"text":"同步屏障 CyclicBarrier","layout":null,"expandState":"expand","note":null},"children":[{"data":{"id":"bu4mq2lbx080","created":1557993842823,"text":"与CountdownLatch区别","layout":null,"note":"1.与countdownLatch区别\n  * 将count值减少与执行await的是相同的线程\n  * count值可重置，即CyclicBarrier可以重复使用\n  * 使用的是独占锁"},"children":[]},{"data":{"id":"bup15zr02ao0","created":1560065785134,"text":"结构","note":"1.属性1\n  * final int parties：线程总数（一起通过栅栏的总数）\n  * int count：还需等待的线程数\n  \n2.属性2 CyclicBarrier基于独占锁和条件队列实现\n  * final ReentrantLock lock；\n  * Condition trip ；\n  * Generation generation ；包含一个布尔值broken。\n \n3.属性3 可执行的任务\n   * final Runnable barrierCommand;\n   * 当所有线程都到齐后，在它们一同通过barrier之前执行\n   * 此任务不是必须的","layout":null},"children":[]},{"data":{"id":"bup1hu2sg1c0","created":1560066713156,"text":"原理","note":"一个线程因为各种原因不能通过，则全部不能通过","layout":null},"children":[{"data":{"id":"bup1jkuyrpk0","created":1560066849820,"text":"下一代 nextGeneration()","note":"最后一个线程到达时调用\n1. signalAll():唤醒条件队列中的所有线程\n2. 重置count为parties\n3. 创建新的Generation对象\n\n代 Generation\n  * 每一个新的barrier是新的一代，因为cyclicBarrier可重复利用","layout":null},"children":[]},{"data":{"id":"bup1oeqqqyo0","created":1560067228325,"text":"打破栅栏 breakBarrier()","note":"1. 标记Generation中的broken 状态\n\n2. 恢复count值为parties\n\n3. 唤醒当前这一代中所有等待在条件队列里的线程（因为栅栏已经打破了）","layout":null},"children":[]},{"data":{"id":"bup1th0xtog0","created":1560067625117,"text":"恢复初始状态 reset()","note":"1. 先后调用 breakBarrier方法和nextGeneration\n\n2. 调用该方法需获取锁\n\n3. 执行该方法时有线程正等待在barrier上，则它将立即返回并抛出BrokenBarrierException异常。","layout":null},"children":[]},{"data":{"id":"bup1uztcpu80","created":1560067744380,"text":"核心方法 await","note":"1. await有两种，带超时和不带超时\n\n2. 调用await的，必须先获取锁\n\n3. 进入await方法时，发现barrier已经被打破，则抛出异常BrokenBarrierException\n\n4. 再检查当先线程是否被中断\n  * 是则breakBarrier（有一个下次被中断了，则其他线程不需等待）\n  * 抛出中断异常\n\n5. 先count自减，判断当前线程是最后一个到达的\n  * 先执行barrierCommand任务\n  * 开启新的一代\n  \n6. 当前线程不是最后一个到达\n  * 调用条件队列的await方法，放进条件队列，挂起线程，此处会判断是否使用了超时机制\n  * 假如被中断唤醒，并且还在当前这一代，则打破屏障（新的一代则不需要）\n\n7. 线程唤醒后，检查是否是被打破而唤醒的\n  * 是，抛出BrokenBarrierException\n  \n8. 当前已是新的一代，说明是各个线程正常到达，前面开启了新的一代，正常返回\n9. 最后判断时候是超时唤醒的，是则抛出超时异常\n  \n  \n  \n  \n  \n  ","layout":null},"children":[]}]}]},{"data":{"id":"bu4m0arzz7s0","created":1557991823172,"text":"信号量 Semaphore","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu4ngpjmvts0","created":1557995930254,"text":"原理","layout":null,"expandState":"expand","note":"1. 创建时可选是否使用公平锁（默认非公平锁），传入state。表示同一时刻允许通过的最大线程\n\n2. 信号量基于共享锁实现，支持多个线程同时获取锁。并支持同一线程同时获取多个资源.\n\n3. 非公平锁实现\n  * 自旋 CAS 直至获取锁，或者锁资源用完\n  * 后面调用共享锁的方法，拿不到放进同步队列，线程挂起\n\n4. 公平锁实现\n  * 获取锁前，先判断同步队列中是否有前驱节点（与ReentrantLock的公平锁一样）\n  \n5. 释放锁 cas自旋增加资源\n  * 成功后调用共享锁的释放锁方法。唤醒同步队列第一个节点线程。"},"children":[]},{"data":{"id":"bu4ngyv9g2o0","created":1557995950548,"text":"使用","layout":null,"note":"1. acuqire\n * 可以获取一个或多个资源（默认一个）\n * 可以使用acquireUninterruptibly，不响应中断，并同时兼容获取一个、多个\n\n2. release  释放也是可以一次释放多个资源\n\n3. 除了使用acquire这种会拿不到会阻塞的方法，还提供了tryacquire这种非阻塞的\n  * 只支持非公平锁\n  * 直接返回布尔值，表示是否获取锁\n  * 可以获取一个或多个\n  * 可以选择超时还是不超时\n  * 超时调用的就是AQS的方法（就是该阻塞还是阻塞，只是阻塞的时间可控，并且自旋会判断时间，阻塞的意义在于，在时间范围内唤醒，是有可能拿到锁的）"},"children":[]},{"data":{"id":"buro3wfilqw0","created":1560333626622,"text":"reducePermits（） 消耗指定信号量","note":"1. 强制减少信号量\n  * 该方法一定成功（需要传入正数，不断cas）\n  * 即使减少后信号量小于0也可以","layout":null},"children":[]},{"data":{"id":"buro5s1a4dk0","created":1560333773782,"text":"drainPermits（） 消耗剩余信号量","note":"1. cas不断自旋，将信号量变为0.\n2. 返回最终消耗的量\n","layout":null},"children":[]}]}]},{"data":{"id":"bu4niyf0whk0","created":1557996106295,"text":"ThreadLocal","expandState":"collapse","layout":null},"children":[{"data":{"id":"bu4nj6ei2fc0","created":1557996123678,"text":"结构：map（ThreadLocalMap）","layout":null},"children":[{"data":{"id":"bu4nk1598kg0","created":1557996190599,"text":"key是当前线程对象","layout":null},"children":[]}]},{"data":{"id":"bu4njjv3ogw0","created":1557996152979,"text":"特点：以空间换时间","layout":null},"children":[]}]},{"data":{"id":"bu4olqt2o880","created":1557999145933,"text":"线程池","expandState":"collapse","layout":null},"children":[{"data":{"id":"bu4olws8d680","created":1557999158942,"text":"大小分配","layout":null},"children":[{"data":{"id":"bu4om4t9n680","created":1557999176419,"text":"IO密集型","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu4oqe3efrc0","created":1557999510080,"text":"CPU核心数 * 2","note":"cpu使用率不高\n\n可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。","layout":null},"children":[]}]},{"data":{"id":"bu4om902tiw0","created":1557999185538,"text":"cpu密集型","layout":null},"children":[{"data":{"id":"bu4oq66pqu80","created":1557999492866,"text":"CPU核心数+1","note":"CPU使用率高。\n若开过多的线程数，增加上下文切换的次数，会带来额外的开销","layout":null},"children":[]}]},{"data":{"id":"bu4omeey31c0","created":1557999197321,"text":"混合型","layout":null},"children":[{"data":{"id":"bu76m5svhwg0","created":1558253078464,"text":"拆分任务","layout":null},"children":[]}]}]},{"data":{"id":"bu4oorilyfs0","created":1557999382569,"text":"结构","layout":null},"children":[]}]},{"data":{"id":"bu4rj7v11aw0","created":1558007411293,"text":"jmm（Java 内存模型）","expandState":"collapse","layout":null},"children":[{"data":{"id":"bu4rl9gv8q80","created":1558007571519,"text":"是什么（概念）","note":null,"layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu59msl3ths0","created":1558058471477,"text":"是一组规则/规范，并不真实存在","layout":null,"expandState":"expand"},"children":[]},{"data":{"id":"bu59mvm91xk0","created":1558058478076,"text":"围绕原子性、有序性和可见性展开","layout":null},"children":[]},{"data":{"id":"bu5fsscawmw0","created":1558075867789,"text":"定义程序中各个变量的访问规则","note":"\n将变量存储到内存\n从内存中取出变量 等细节\n","layout":null,"priority":null,"expandState":"expand"},"children":[{"data":{"id":"bu5gjdodkaw0","created":1558077951699,"text":"包括实例字段、静态字段和构成数值对象的元素等公共信息","layout":null,"progress":9,"note":"数组也是对象\n"},"children":[]},{"data":{"id":"bu5gjjj6r4o0","created":1558077964446,"text":"不包括局部变量与方法参数，因为这些是线程私有的","layout":null,"progress":1},"children":[]}]}]},{"data":{"id":"bu5hhe90qkg0","created":1558080617329,"text":"解决了什么问题（作用）","expandState":"collapse","layout":null},"children":[{"data":{"id":"bu5hhi4tmio0","created":1558080625783,"text":"共享内存冲突","layout":null},"children":[{"data":{"id":"bu6zldtqnk80","created":1558233269797,"text":"每个线程操作数据时，会保存使用到的共享内存的变量副本。多个线程之间就可能出现数据不一致","layout":null},"children":[]}]},{"data":{"id":"bu5hhu8z9k00","created":1558080652155,"text":"指令重排序","layout":null},"children":[{"data":{"id":"bu6zu2k5db40","created":1558233950550,"text":"为了优化程序性能，编译器或运行时环境会对指令进行重排序","layout":null},"children":[{"data":{"id":"bu6zyp5tj680","created":1558234313206,"text":"重排序不影响单线程下程序执行的结果","layout":null},"children":[]},{"data":{"id":"bu701jsa9so0","created":1558234536596,"text":"不存在依赖关系的才允许重排","note":"程序其实不一定能判断出是否会影响原来的结果，因为结果是执行之后才知道的，因此直接禁止有依赖关系的重排\n","layout":null},"children":[]}]}]}]},{"data":{"id":"bu6zhux626w0","created":1558232993553,"text":"有什么用（目标）","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bu6zj336qs80","created":1558233089695,"text":"通过数据同步协议，保证内存副本之间的数据一致性，同时防止重排序对程序的影响。","layout":null},"children":[]}]},{"data":{"id":"bu6zjlwniso0","created":1558233130659,"text":"原理","expandState":"expand","layout":null},"children":[{"data":{"id":"bu6lathh5t40","created":1558192946339,"text":"内存屏障","layout":null,"note":"Store：工作内存取出（给主内存）\nLoad：存进工作内存（把主内存的值）\n\n屏障是一组指令。\n将代码生成汇编，可看见一个lock前缀指令，就是此屏障","expandState":"expand"},"children":[{"data":{"id":"bu6lb3gyr1c0","created":1558192968076,"text":"StoreStroe","layout":null},"children":[{"data":{"id":"bu6lfhlmb8o0","created":1558193312289,"text":"屏障前的store（写）操作，对屏障后的store操作可见（保障了排序及可见这2项）","layout":null},"children":[]}]},{"data":{"id":"bu6ldv8t0nk0","created":1558193185261,"text":"StoreLoad","layout":null},"children":[{"data":{"id":"bu6lpvtxzaw0","created":1558194126909,"text":"屏障前的Store操作对屏障后的读操作可见","layout":null,"note":"刷新处理器缓存"},"children":[]},{"data":{"id":"bu6lqh97ovk0","created":1558194173545,"text":"通常是最消耗性能的一个屏障，包含其他几个屏障的功能","layout":null},"children":[]}]},{"data":{"id":"bu6le5wxqwg0","created":1558193208488,"text":"LoadStore","layout":null},"children":[{"data":{"id":"bu6lszuxrv40","created":1558194370769,"text":"屏障后的写操作要在屏障前的读操作完成前","layout":null,"note":"刷新处理器缓存\n\n使其他线程volatile变量的写更新对volatile读操作的线程可见。\n\n其他线程一改，马上就知道\n"},"children":[]}]},{"data":{"id":"bu6lefdciio0","created":1558193229072,"text":"LoadLoad","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu6lrnzupwg0","created":1558194266581,"text":"屏障后的读操作要在屏障前的读操作完成后","layout":null,"note":"刷新处理器缓存"},"children":[]}]}]},{"data":{"id":"bu5fgbzs6ls0","created":1558074891833,"text":"结构","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bu5frzvr4c00","created":1558075805838,"text":"类比cpu","note":"1、cpu的寄存器速度比内存高几个数量级\n\n2、引入高速缓存 缓解这种矛盾\n\n3、导致 缓存不一致 等新的问题","layout":null},"children":[]},{"data":{"id":"bu5fgqdpb7k0","created":1558074923150,"text":"工作内存","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu5h2mzn85k0","created":1558079460891,"text":"1、虚拟概念，并不真实存在","layout":null},"children":[]},{"data":{"id":"bu5h3zlu8a00","created":1558079566719,"text":"2、位置包括了缓存，写缓冲区，寄存器等","layout":null},"children":[]},{"data":{"id":"bu5h8rw14gw0","created":1558079941741,"text":"3、每条线程都有自己的工作内存","layout":null},"children":[]},{"data":{"id":"bu5h9isim5c0","created":1558080000302,"text":"4、存储了主内存中共享变量的副本","layout":null},"children":[]}]},{"data":{"id":"bu5fgm3tjpk0","created":1558074913845,"text":"主内存","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu5gt7bzgp40","created":1558078721531,"text":"1、jvm内存的一部分","layout":null},"children":[]},{"data":{"id":"bu5gtec0l5s0","created":1558078736770,"text":"2、所有变量（见上文）存储于此","layout":null},"children":[]}]}]},{"data":{"id":"bu5l1te3qgg0","created":1558090680901,"text":"内存交互基本操作","note":"这些操作都是原子性的\n","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bu5l1xzlx5c0","created":1558090690909,"text":"lock (锁定) ——作用于主内存变量","layout":null,"note":"把变量标识为一条线程独占的状态"},"children":[]},{"data":{"id":"bu5l2yswchk0","created":1558090771044,"text":"unlock (解锁) ——主内存","layout":null,"note":"把锁定状态的变量释放\n\n释放后的变量才可以被其他线程锁定。"},"children":[]},{"data":{"id":"bu5l4j4lucg0","created":1558090893652,"text":"read (读取) ——主内存","layout":null,"note":"主内存传输到线程的工作内存中，以便随后的load动作使用。","priority":1},"children":[]},{"data":{"id":"bu5l5dhzx140","created":1558090959765,"text":"load (载入) ——工作内存","layout":null,"note":"将read操作 从主内存中得到的变量值\n放入\n工作内存的变量副本中。","priority":2},"children":[]},{"data":{"id":"bu5l9ef41080","created":1558091275224,"text":"use (使用) ——工作内存","note":"把工作内存中一个变量的值传递给执行引擎","priority":3,"layout":null},"children":[]},{"data":{"id":"bu5lbveyzsw0","created":1558091468949,"text":"assign (赋值) ——工作内存","note":"把一个从执行引擎接收到的值赋给工作内存的变量","priority":4,"layout":null},"children":[]},{"data":{"id":"bu5lcwcscps0","created":1558091549358,"text":"store (存储) ——工作内存","note":"工作内存中一个变量的值传送到主内存中，以便随后write操作使用。","priority":5,"layout":null},"children":[]},{"data":{"id":"bu5lgoeuouw0","created":1558091845525,"text":"write (写入) ——主内存","note":"把store操作从工作内存中得到的变量的值放入主内存的变量中。","layout":null,"priority":6},"children":[]},{"data":{"id":"bu6lhfrulwg0","created":1558193465041,"text":" ","image":"http://kityminder-img.gz.bcebos.com/9017ece30b0233a9374756cb834df34b2542750e","imageTitle":"","imageSize":{"width":196,"height":200},"layout":null},"children":[]}]},{"data":{"id":"bu700c57en40","created":1558234441599,"text":"happens-before关系","layout":null},"children":[{"data":{"id":"bu700e627cw0","created":1558234446004,"text":"A  happens-before B，即A的结果对B可见","layout":null},"children":[{"data":{"id":"bu703drytbs0","created":1558234680245,"text":"单线程下，按照代码顺序，书写在前面的操作 happens-before 书写在后面的操作。","layout":null},"children":[]},{"data":{"id":"bu8njob2u6w0","created":1558402402479,"text":"锁定规则 一个unLock操作 happens-before 后面对同一个锁的lock操作","layout":null},"children":[]},{"data":{"id":"bu8nklc76e00","created":1558402474381,"text":"volatile变量规则 对一个变量的写操作 happens-before 后面对这个变量的读操作。","layout":null},"children":[]},{"data":{"id":"bu8nkqrvjzk0","created":1558402486213,"text":"传递规则 如果操作A happens-before 操作B，而操作B又 happens-before 操作C，则可以得出操作A happens-before 操作C。","layout":null},"children":[]},{"data":{"id":"bu8nkzw85680","created":1558402506067,"text":"线程启动规则 Thread对象的start()方法 happens-before 此线程的每个一个动作。","layout":null},"children":[]},{"data":{"id":"bu8nl4zdc3s0","created":1558402517141,"text":"线程中断规则 对线程interrupt()方法的调用 happens-before 被中断线程的代码检测到中断事件的发生。","note":"检测中断的时候，能够感知到已经执行了中断\n","layout":null},"children":[]},{"data":{"id":"bu8nlvva2vk0","created":1558402575667,"text":"线程终结规则 线程中所有的操作都 happens-before 线程的终止检测","note":"终止检测，能检测出这个线程正在干什么（用于判断线程究竟终结了没）\n\n可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。","layout":null},"children":[]},{"data":{"id":"bu8nnvdnlo00","created":1558402731329,"text":"对象终结规则   一个对象的初始化完成 happens-before 他的finalize()方法的开始","note":"GC在回收对象之前调用finalize()方法\n\nfinalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的\n\nJava语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行\n\n因为是回收相关的，因此是创建对回收可见，即该对象的创建被感知了，方便后面的回收执行","layout":null},"children":[]}]}]}]},{"data":{"id":"bu70abex1u80","created":1558235223651,"text":"volatile","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bu70ajvs75k0","created":1558235242085,"text":"写","layout":null},"children":[{"data":{"id":"bu70cikjpcw0","created":1558235395957,"text":"1、改变线程  工作内存   中变量副本的值","layout":null},"children":[]},{"data":{"id":"bu70g8eau8o0","created":1558235687269,"text":"2、将改变后的副本的值从  工作内存  刷新到  主内存","layout":null},"children":[]}]},{"data":{"id":"bu70am5fj9k0","created":1558235247022,"text":"读","layout":null},"children":[{"data":{"id":"bu70hsb6xgo0","created":1558235808980,"text":"1、从  主内存   中读取变量的最新值到线程的     工作内存 中","layout":null},"children":[]},{"data":{"id":"bu70ipugcjc0","created":1558235881980,"text":" 2、从  工作内存   中读取volatile变量的副本","layout":null},"children":[]}]},{"data":{"id":"bu70aowo3bs0","created":1558235253023,"text":"只保证变量单个操作的原子性，不保证代码原子性","note":"如：多个线程循环加，结果将是不可预料\n","layout":null},"children":[]},{"data":{"id":"bu70kqz8jyo0","created":1558236041173,"text":"原理","layout":null},"children":[{"data":{"id":"bu70ldtiqu00","created":1558236090894,"text":" ","image":"http://kityminder-img.gz.bcebos.com/d4a0bf93bd38aa0e3d4cb76dbcf8bfd0b900640a","imageTitle":"","imageSize":{"width":200,"height":161},"layout":null},"children":[]}]}]},{"data":{"id":"bu711k6jvpk0","created":1558237358569,"text":"final","layout":null},"children":[{"data":{"id":"bu711mvcje80","created":1558237364422,"text":"final变量一旦初始化完成，立刻回写到主内存","layout":null},"children":[]},{"data":{"id":"bucj2413ajs0","created":1558795981536,"text":"变量分类","expandState":"expand","layout":null},"children":[{"data":{"id":"bucj2e5fvgw0","created":1558796003567,"text":"当final变量未初始化时系统不会进行隐式初始化，会出现报错","layout":null},"children":[]},{"data":{"id":"buciyelxmi00","created":1558795691107,"text":"类（静态）变量","layout":null},"children":[{"data":{"id":"buciz1l4hy00","created":1558795741125,"text":"必须在声明时赋值，或在静态代码块中赋值（2选1）","layout":null},"children":[]}]},{"data":{"id":"buciyt62s6g0","created":1558795722800,"text":"实例变量","layout":null},"children":[{"data":{"id":"bucizvvji9c0","created":1558795807058,"text":"必须在声明时赋值，或在非静态代码块，或构造函数中赋值（3选1）","layout":null},"children":[]}]},{"data":{"id":"bucj2tlfma00","created":1558796037186,"text":"局部变量","layout":null},"children":[{"data":{"id":"bucj3mhgj200","created":1558796100072,"text":"只能赋值一次（以上两种也是）","layout":null},"children":[]}]},{"data":{"id":"bucjdiym8740","created":1558796876044,"text":"基本数据类型 和 引用类型（对象）","layout":null},"children":[{"data":{"id":"bucje24agp40","created":1558796917746,"text":"都不能重新赋值，但是可以改变引用类型的属性","layout":null},"children":[]}]}]},{"data":{"id":"bucjj1ne6r40","created":1558797308545,"text":"方法","expandState":"expand","layout":null},"children":[{"data":{"id":"bucjj4ozjko0","created":1558797315173,"text":"final方法不能重写，可以重载","layout":null},"children":[]}]},{"data":{"id":"bucjjebahi80","created":1558797336111,"text":"final类","expandState":"expand","layout":null},"children":[{"data":{"id":"bucjjjkdom80","created":1558797347545,"text":"不可继承","layout":null},"children":[]}]},{"data":{"id":"bucjmm7mge00","created":1558797588396,"text":"不变类","note":"创建该类的实例后，实例的实例变量是不可变的\n\n1、使用private和final修饰成员变量\n\n2、构造函数中初始化成员变量\n\n3、不提供setter方法\n\n如果有必要就重写Object类 的hashCode()和equals()方法，应该保证用equals()判断相同的两个对象其Hashcode值也是相等的。\n\n","expandState":"collapse","layout":null},"children":[{"data":{"id":"bucjor3xl2g0","created":1558797755785,"text":"拓展hashcode、equals","note":"1、通过内存地址算出hashcode\n\n2、内存地址相同，则hashcode相同\n\n3、hashcode相同、内存地址不一定相同\n\n4、判断一个类是否相同，一般使用equals，此时要求hashcode也相同，因为很多类的实现，默认使用类的hashcode。如 map 的key","layout":null},"children":[]}]},{"data":{"id":"bucjrw0n25c0","created":1558798001563,"text":"final的重排序","layout":null},"children":[{"data":{"id":"buckcp86b8g0","created":1558799632428,"text":"类变量在加载类的时候已经确定，无多线程问题","layout":null},"children":[]},{"data":{"id":"buckdeqag600","created":1558799687943,"text":"实例变量","note":null,"expandState":"expand","layout":null},"children":[{"data":{"id":"budcvgwb75c0","created":1558880094293,"text":"基本类型","note":"在对象引用为所有线程可见之前，对象的final域已经被正确初始化过（而普通域就不具有这个保障。）\n\n1、假如有final修饰的变量a，及普通的变量b(均在构造函数内赋值)\n\n2、类中还有一个该类的静态成员变量（类型是当前类）\n\n3、线程1 new 一个类，赋值给当前成员变量\n\n4、线程2 读取该成员变量\n\n5、则非final的赋值可能会被重排序到构造函数之外（线程2读取的是初始化之前的值）\n\n\n","expandState":"expand","layout":null},"children":[{"data":{"id":"budcy0hmpo80","created":1558880293670,"text":"写","expandState":"expand","layout":null},"children":[{"data":{"id":"buckgymn9ns0","created":1558799966351,"text":"对于编译器：JMM禁止编译器把final域的写重排序到构造函数之外","layout":null},"children":[]},{"data":{"id":"buckfhbl0rk0","created":1558799850313,"text":"对于处理器：在构造函数return之前，编译器插入一个Storestore屏障","layout":null},"children":[{"data":{"id":"bucki9pttr40","created":1558800068852,"text":"该屏障会禁止处理器将屏障前的写重排序到屏障后","layout":null},"children":[]}]}]},{"data":{"id":"budcy5oh04g0","created":1558880304967,"text":"读","layout":null},"children":[{"data":{"id":"budcy7wgvbs0","created":1558880309804,"text":"禁止初次读对象的引用  与  读该对象的final域的重排","note":"即禁止还没对变量进行引用指向，就直接读取其final的成员域","layout":null},"children":[]},{"data":{"id":"budczv9gl600","created":1558880439020,"text":"对于处理器（仅处理器） 读final域之前插入一个Loanloan屏障","note":"实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。\n\n但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。","layout":null},"children":[]}]}]},{"data":{"id":"budcjg2mamg0","created":1558879152129,"text":"引用类型的变量","expandState":"expand","layout":null},"children":[{"data":{"id":"budd2lawf2o0","created":1558880652432,"text":"包含基本类型的所有约束","layout":null},"children":[]},{"data":{"id":"budd35cor6o0","created":1558880696075,"text":"对final修饰的引用类型变量域（如数组），构造函数内对该变量域的成员域的赋值 与 构造出来的对象赋值给一个变量 不能重排序","note":"另外一个线程读取final修饰的引用类型的其中一个属性（即字段、域）\n\n读取的肯定是在构造函数内完成赋值的\n\n\n对变量的成员域是可修改的，修改操作不在构造函数内，则读取线程不一定能及时读到","layout":null},"children":[]}]},{"data":{"id":"buddm3556ds0","created":1558882180185,"text":"例外","note":"在其他线程可见之前，必须是构造函数完成之后。但是前提是，在完成构造函数之前，对象不能溢出\n\n如 成员变量 = thisdeng'yu'ju;\n","layout":null},"children":[]}]}]}]},{"data":{"id":"bu712psh8cg0","created":1558237449143,"text":"synchronized","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bu712ryhso00","created":1558237453860,"text":"synchronized锁住的区域。读，只能从主内存中读。离开同步区时，刷新值到主内存","layout":null},"children":[]}]},{"data":{"id":"bu715bva76o0","created":1558237653930,"text":"long和double（64位数据类型）","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bu715einp200","created":1558237659697,"text":"上面的8种原子性操作，对于没有加volatile的long和double，主内存与工作内存的数据交换不是原子性的，是按照2次32位来执行","note":"不过，目前各商用虚拟机都选择把64位数据的读写操作作为原子操作来对待\n\n因此我们在编写代码时一般不需要把用到的long和double变量专门声明为volatile。","layout":null},"children":[]}]}]},{"data":{"id":"bue8yflsdmg0","created":1558970602090,"text":"Lock体系","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bue8zxifza80","created":1558970719434,"text":"Lock比较于Synchronize","expandState":"expand","layout":null},"children":[{"data":{"id":"buig9nwqeog0","created":1559397469768,"text":"1、lock提供了显式的、可操作性的加解锁","layout":null,"expandState":"expand","note":"1、synchronize执行完或异常会自动释放锁\n\n2、必须执行unlock()来解锁，finally中执行\n\n3、lock.lock() 不可中断锁"},"children":[]},{"data":{"id":"buigc5q0vbs0","created":1559397665272,"text":"2、可 响应中断 式获取锁","expandState":"expand","layout":null},"children":[{"data":{"id":"buigywaxelc0","created":1559399447144,"text":"lock.lockInterruptibly()","layout":null,"note":" 等待获取锁，等待期间其他线程调用了此线程的中断方法，则中断等待，抛出InterruptedException"},"children":[]}]},{"data":{"id":"buigcg3s9m80","created":1559397687872,"text":"3、非阻塞式获取锁","layout":null,"expandState":"expand"},"children":[{"data":{"id":"buih2v4pr7k0","created":1559399758048,"text":"lock.tryLock()","layout":null,"note":"不等待，拿不到锁直接返回flase 否则返回true"},"children":[]}]},{"data":{"id":"buih3ezo76g0","created":1559399801279,"text":"4、超时获取锁","layout":null,"expandState":"expand"},"children":[{"data":{"id":"buih459oma80","created":1559399858481,"text":"lock.tryLock(10, TimeUnit.SECONDS)","layout":null,"note":"  可响应中断、并超过一定时间直接返回false\n  \n  响应中断的意思，就是发现中断了，会抛出中断异常返回。"},"children":[]}]}]},{"data":{"id":"buih7c5oa740","created":1559400108568,"text":"AQS（AbstractQueuedSynchronizer） 抽象队列同步器","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"buihi8exr680","created":1559400962427,"text":"涉及到的设计模式","layout":null},"children":[{"data":{"id":"buihiw0y6480","created":1559401013824,"text":"模板方法设计模式","note":"模板方法模式在一个方法中定义一个算法的骨架\n\n而将一些步骤的实现延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现。","layout":null},"children":[]}]},{"data":{"id":"buivd0heh480","created":1559440048880,"text":"作用与结构","layout":null},"children":[{"data":{"id":"buivdnvdbxc0","created":1559440099790,"text":"同步器是同步组件（锁以及CountDownLatch等）的基础框架","layout":null},"children":[]},{"data":{"id":"buivek4vg6w0","created":1559440170022,"text":"依赖一个int类型来控制同步状态，一个FIFO的队列构成等待队列","layout":null,"note":"state变量，state大于0表示锁被占用，数字代表被占用的次数（可重入锁，可多次获取）\n\n此变量是AQS里面的，注意区分同步队列节点里面的waitstatus"},"children":[]},{"data":{"id":"buivfrxb3k00","created":1559440265343,"text":"AQS的子类必须重写几个protected修饰的 用于改变同步状态的逻辑的方法","expandState":"expand","layout":null,"note":"这些方法没有使用abstract修饰，而是方法中直接抛出指定异常"},"children":[]},{"data":{"id":"buivkozmxbs0","created":1559440650774,"text":"其他方法主要是实现了排队和阻塞机制","layout":null,"expandState":"expand","note":"即同步状态的管理，线程的排队，等待和唤醒这些底层实现由AQS实现，而同步状态的逻辑由子类决定"},"children":[]},{"data":{"id":"buivxr0beg80","created":1559441673903,"text":"AQS支持独占式或共享式修改同步状态，满足不同同步器的需求","layout":null},"children":[]}]},{"data":{"id":"buivqtb8jiw0","created":1559441130368,"text":"自定义同步组件（锁）","layout":null},"children":[{"data":{"id":"buivuurqchs0","created":1559441446999,"text":"类似ReentrantLock,建议 使用一个静态内部类作为AQS子类","layout":null},"children":[]},{"data":{"id":"buivvnervko0","created":1559441509342,"text":"子类实现同步状态的修改逻辑","layout":null,"expandState":"expand","note":"getState(),setState(),compareAndSetState()方法进行修改同步状态"},"children":[]},{"data":{"id":"buiw1vzkol40","created":1559441998199,"text":"锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；","layout":null},"children":[]},{"data":{"id":"buiw2ndhtuo0","created":1559442057814,"text":"同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作","layout":null},"children":[]}]},{"data":{"id":"buiwj6renlk0","created":1559443353840,"text":"原理","layout":null,"note":"NODE节点\n\n1:取消\n0:初始状态\n-1：此节点的后继节点阻塞等待\n-2：等待阻塞中（用于Condition queu）\n-3：下一个获取共享锁的将无条件获取\n\n\n\nint CANCELLED =  1//节点从同步队列中取消\nint SIGNAL    = -1//后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行；\nint CONDITION = -2//当前节点进入等待队列中\nint PROPAGATE = -3//表示下一次共享式同步状态获取将会无条件传播下去\nint INITIAL = 0;//初始状态","expandState":"expand"},"children":[{"data":{"id":"buiwylfqd4o0","created":1559444561249,"text":"同步队列结构","layout":null,"expandState":"expand"},"children":[{"data":{"id":"buiwyrzlysg0","created":1559444575511,"text":"队列是双向链表结构，AQS通过持有头尾指针管理同步队列","layout":null},"children":[]},{"data":{"id":"buix0mblmh40","created":1559444719904,"text":"获取不了锁的线程，将进入队列","layout":null},"children":[]},{"data":{"id":"buix1q7dae00","created":1559444806719,"text":"通过AQS源码，其静态内部类Node，可了解节点结构及等待状态信息(节点组成队列)","layout":null},"children":[]}]},{"data":{"id":"bujcu582cfs0","created":1559489350258,"text":"独占锁","expandState":"expand","layout":null,"note":"1、独占锁一次只能有一个线程持有锁\n\n2、唤醒从链表头开始，一次唤醒一个线程，因为唤醒多个线程没意义\n\n3、但此时并不代表就是公平锁，因为还会有新增的线程会尝试获取锁"},"children":[{"data":{"id":"buiy5dshdkw0","created":1559447914264,"text":"独占锁的获取（acquire方法）","layout":null,"expandState":"expand"},"children":[{"data":{"id":"buiy5iycnbs0","created":1559447925503,"text":"tryAcquire ","layout":null},"children":[{"data":{"id":"buiy5q39lgw0","created":1559447941038,"text":"成功直接返回","layout":null},"children":[]},{"data":{"id":"buiy5yno3eg0","created":1559447959686,"text":"不成功放进同步队列","layout":null,"expandState":"expand","note":"1、将线程构建成一个Node节点\n\n2、当前队列尾节点是否为空，不为空，则比较替换当前节点为尾节点。操作失败则走第三步\n\n3、尾节点为空、或不为空但操作失败（被其他线程抢占尾部）\n\n3.1 自旋\n\n3.2 获取尾部节点，尾部为空则比较替换，创建空节点为头部（及尾部）\n\n3.3 操作3.2中没有return，操作3.3必须执行成功，即比较替换，将当前节点置于尾部（自旋中会不断获取最新的尾部节点）"},"children":[]}]},{"data":{"id":"buiyh1lp83k0","created":1559448828103,"text":"acquireQueued 队列中的线程如何获取锁","layout":null},"children":[{"data":{"id":"buiyko5fsrs0","created":1559449112278,"text":"自旋，当前节点的prev是否为head节点，并竞争锁","layout":null},"children":[{"data":{"id":"buiym1itvl40","created":1559449219750,"text":"获取成功，成为头部，清除prev，thread","layout":null,"note":"1、成功获取锁的同时，成为head。成为头部节点后，立即清除前驱节点引用，及当前线程的引用\n\n2、原头部的下一节点指向也清空，则原头部无任何引用，方便GC回收\n\n2.1 此处方便回收，猜测是指方便下一个对象回收\n当下一对象出列时假如还被引用，则不好回收（上一对象可能还没回收）\n成为头部节点后，立即情况前驱节点引用，及当前线程引用\n\n3、head的下一个节点是将来下一个唤醒的节点（可以竞争锁）","expandState":"expand"},"children":[]},{"data":{"id":"buj5lh2xyr40","created":1559468923023,"text":"获取失败，前驱节点状态改为signal，阻塞当前线程","layout":null,"expandState":"expand","note":"1、设置前驱节点状态为signal\n  1.1 表示该节点后的后继节点会阻塞等待\n  1.2 设置失败则回到上一步自旋，直至获取锁或者当前线程阻塞\n  \n2、LockSupport.park(this); 阻塞当前线程"},"children":[]}]}]}]},{"data":{"id":"buj63w4xm0g0","created":1559470366350,"text":"独占锁的释放","layout":null,"expandState":"expand"},"children":[{"data":{"id":"buj645bj3280","created":1559470386340,"text":"获取head 节点的下一节点，并唤醒该节点的线程","layout":null},"children":[{"data":{"id":"buj653qezuw0","created":1559470461251,"text":"LockSupport.unpark(s.thread);","layout":null},"children":[]}]}]},{"data":{"id":"buj6ls3lqog0","created":1559471768118,"text":"可中断式获取锁","layout":null,"expandState":"expand"},"children":[{"data":{"id":"buj6ogsjivc0","created":1559471978597,"text":"跟acquire几乎一致，但会返回当前线程中断状态，假如已中断，外层抛出异常","note":"线程已阻塞，如何返回状态？\n\n返回需唤醒，唤醒后发现已中断，则不继续尝试获取锁，直接退出\n\n因此不是设置了中断马上生效，还是需要唤醒\n","layout":null},"children":[]}]},{"data":{"id":"buj6yfaylwo0","created":1559472758999,"text":"超时可中断获取锁","layout":null,"expandState":"expand"},"children":[{"data":{"id":"buj6yn5oa680","created":1559472776093,"text":"跟可中断差不多，但是会对时间进行判断，并且阻塞的方法会指定阻塞的时间 LockSupport.parkNanos(this, nanosTimeout);","layout":null},"children":[]}]}]},{"data":{"id":"bujcw3cjasg0","created":1559489502904,"text":"共享锁","expandState":"expand","layout":null,"note":"与独占锁的区别：\n"},"children":[{"data":{"id":"buj7254v8k80","created":1559473050320,"text":"共享锁的获取","layout":null,"note":"1、获取锁的同时，成为头部\n\n2、共享锁获取后，如果还有资源，会继续唤醒下一个线程\n\n3、下一线程获取锁后会成为新的头部\n即：某一线程可能还没释放锁，就已经脱离队列了\n\n4、虽然共享锁可以给多个线程获取，但是队列节点的唤醒、头部替换还是逐个逐个\n\n5、跟独占锁一样，获取失败的线程进入同步队列，并把自己的前驱节点的waitstatus改为Signa\n\n-- 获取锁的返回值\n该值小于0，获取共享锁失败\n\n该值大于0，获取共享锁成功，且有剩余资源\n\n该值等于0，获取共享锁成功，无剩余资源\n\n\n"},"children":[{"data":{"id":"bumc0euurf40","created":1559791700173,"text":"addWaiter方法","note":"1、独占锁中，addWaiter(Node.EXCLUSIVE) 是null值\n即 Node节点的nextWaiter值为空、\n\n2、共享锁中，该值Node.SHARED为一个新的Node对象\n\n3、注意此nextWaiter所串联起来的单向链表，与同步队列里的双向链表没任何关系，此处仅标识该锁是共享锁","layout":null},"children":[]}]},{"data":{"id":"bujcvj5tqiw0","created":1559489458962,"text":"可中断锁、超时可中断锁也与独占锁差不多","layout":null},"children":[]},{"data":{"id":"bujcwcxowf40","created":1559489523774,"text":"共享锁的释放","layout":null,"note":"有两个地方会调用共享锁的释放doReleaseShared\n（一个节点可能会触发两次该方法）\n1、获取锁\n2、释放当前锁\n\n获取锁后，如果还有剩余资源，则继续唤醒头结点的下一个节点\n\n释放锁，因为释放锁会产生新的资源，因此继续唤head的下一个节点\n\n\n\n"},"children":[{"data":{"id":"bumld5bmx2g0","created":1559818088143,"text":"多线程释放","note":"多个线程同时释放锁，唤醒下一个线程，假如发现唤醒的是同一个，则需要继续唤醒下一个\n\n1、cas改变状态，保证是当前线程操作的才执行unparkSuccessor（唤醒头部的下一节点），否则自旋下一次\n\n2、其他线程解锁成功，head会变化，此时也需继续自旋\n\n3、如果是在第一个if中返回false，说明其他线程早一步进入，此时当前head状态改为-3.表示下一次获取锁无条件传播，因为存在多次解锁，说明资源有剩\n\n4、改成-3失败重试，什么时候会失败，有新的节点加入，新节点是先加入队列，再将前驱节点的状态变为signal，因此可以符合最外层的if（图中无箭头）\n\n此时不重试，将退出自旋，因为新节点刚刚挂起，头部节点未变化。继续自旋则跑图中第一个if逻辑\n\n5、为什么会有队列节点增加，因为当前线程释放锁的时候，该线程已经获取失败","image":"http://kityminder-img.gz.bcebos.com/bb97c9c33bed80f72176a6f45baac75d15764118","imageTitle":"","imageSize":{"width":200,"height":80},"layout":null},"children":[]}]}]}]}]},{"data":{"id":"bund8jijm9c0","created":1559896718292,"text":"ReentrantLock","layout":null},"children":[{"data":{"id":"bunda78e1940","created":1559896848286,"text":"基于AQS实现的独占锁，可重入锁","note":"\n基本都是使用AQS里面的方法，具体实现根据公平锁、非公平锁而不同。\n\n重入锁：\n1、通过AQS中的state表示锁的状态\n2、cas获取锁，state==0表示无锁\n3、state值的次数表示获取锁的次数，释放锁的时候，stats降为0才算是完全释放锁\n4、变量exclusiveOwnerThread 记录当前持有锁的线程","layout":null},"children":[]},{"data":{"id":"bundqh0k3fc0","created":1559898123406,"text":"公平锁、非公平锁","note":"默认非公平锁，即AQS的默认实现\n（新来的线程可以与队列的第一个唤醒的线程竞争锁）\n\n公平锁：获取锁的时候，保证能参与竞争的是队列中的第一个线程\n\n队列中无等待线程，则cas竞争。\n\n性能：非公平锁更好，因为有些还没阻塞的线程可以参与竞争，减少了线程的切换。\n","layout":null},"children":[]}]},{"data":{"id":"bunfbj1rvfk0","created":1559902594590,"text":"ReentrantReadWriteLock","note":"1、32位的int类型变量state，记录了写锁、读锁的获取次数\n\n2、高16位记录的是读锁次数，获取时无符号右移>>>16位即可获取\n\n3、低16位是写锁获取次数，获取时与1<<16-1（高16位是0，低16位是1的数）与运算获取\n\n性能：大部分是读的场景下（缓存设计），独占锁太耗性能。只使用共享锁则不能保证数据安全，此时可以使用读写锁","layout":null},"children":[{"data":{"id":"bunfhgpxfm00","created":1559903059705,"text":"写锁","note":"写锁获取：\n1、当读锁 已经被读线程获取，或者写锁 被其他线程获取，获取失败\n\n2、写锁是独占锁，可重入\n\n3、写锁释放，写锁是低16位，并且此时无读锁。state直接就是获取锁的ci'suh","layout":null},"children":[]},{"data":{"id":"bunht6dzu540","created":1559909619806,"text":"读锁","note":"1、读锁获取\n读锁是一种共享式的锁。当前已被获取写锁，且获取写锁的不是当前线程，获取失败\n2、否则cas获取读锁，比较替换时，加锁的是一个读锁单位 1<<16 因为读锁是高16位\n\n3、读锁释放，减去一个读锁单位","layout":null},"children":[]},{"data":{"id":"buniaadejig0","created":1559910960669,"text":"锁降级","note":"由于一个线程获取写锁后可以继续获取读锁。当释放写锁后，就只持有读锁，此时锁降级了。","layout":null},"children":[]}]},{"data":{"id":"bunk6qod34w0","created":1559916324922,"text":"Condition机制","expandState":"expand","layout":null},"children":[{"data":{"id":"bunkdbw36o00","created":1559916841287,"text":"对比Object的等待、通知机制","note":"1、对象的wait方法，配合对象监视器（即Synchornize）使用，需要获取锁后使用，是java底层级别的\n\n2、Condition与Lock配合完成等待通知机制，是语言级别的，具有更高的可控制性和扩展性\n\n3、wait对应condition的await方法，都需要先获取锁，并且调用后释放锁\n\n---- 区别\n 1、condition有不响应中断的，Object的没有\n \n 2、LOCK支持多个条件队列，object只支持一个\n \n 3、condition支持超时await，object不支持","layout":null},"children":[]},{"data":{"id":"bunkz1jlj000","created":1559918542775,"text":"条件队列","note":null,"layout":null},"children":[{"data":{"id":"bunlfwzvwj40","created":1559919865067,"text":"对比同步队列","note":"1、new 一个Condition对象就会有一个条件队列，而同步队列只有一个\n\n2、同步队列是双向链表，使用prev，next串联。条件队列是单向列表，使用nextWaiter串联（Node对象都是AQS里面的那个）\n\n3、waitstatus，在条件队列中，只使用值CONDITION，表示状态正常等待（其他值则要出队）\n\n4、一般来说条件队列与同步队列互相独立，互不影响，但是在条件队列中被唤醒的线程假如获取锁失败，则要加入到同步队列中（即使获取锁成功，也要先进入yi'ci'dui）\n\n5、进入同步队列是因为获取不了锁，而进入条件队列的肯定已经获取锁的，进入队列后再释放锁，挂起","layout":null},"children":[]},{"data":{"id":"bunlgj9ab3s0","created":1559919913525,"text":"单向链表结构","note":"1、虽然是单向链表，但是也有头尾两节点的指向，因此可以一直获取最新的head、tail\n\n","layout":null},"children":[]}]},{"data":{"id":"buo0ipc1tqo0","created":1559962400130,"text":"await","note":"1、放进条件队列。入队的新节点不需要CAS操作，因为此时是有拿到锁的。并且条件队列不需要创造空的头结点，直接使用第一个即可\n\n2、先入队，然后释放锁，重入了N次也是一次性释放。然后挂起线程\n\n---\n\n3、当唤醒后，尝试获取锁，失败则继续阻塞，prev节点设置为signal（AQS基本操作）\n\n4、因此await方法返回后，肯定是已经获取锁的","layout":null},"children":[{"data":{"id":"buo7ngzd45c0","created":1559982521538,"text":"中断机制","note":"线程唤醒，可能是被signal，也有可能是被中断，但是无论哪一种，线程都必须从条件队列移到同步队列去竞争锁。中断的处理是获取锁后在进行\n\n1、线程在signal前被中断。\n在唤醒的时候，首先会检查是否被中断\n此时为THROW_IE（-1）\n\n2、在signal后被中断（不一定已经获取锁），此时为REINTERRUPT（1）\n\n3、在获取锁后，对于THROW_IE，await方法会抛出中断异常，REINTERRUPT则只记录一下中断标记\n\n4、可以理解为中断不能对已经signal产生效果，因为该中断来的太迟","layout":null},"children":[]}]},{"data":{"id":"bunz5xay44o0","created":1559958577633,"text":"signalAll，将条件队列的节点全部、逐个移到同步队列末尾","note":"1、跟await，signal一样，调用需先获得锁\n\n2、先将队列的 前后指向设置为null（firstWaiter，lastWaiter，猜测help GC）\n\n3、将队列全部成员，从头开始遍历，逐个移到同步队列末尾，将前驱节点状态代为Signal\n\n4、与正常线程加入同步队列不一样的：不会去从末尾开始跳过cancel的节点，只要此时前驱节点处于被取消的状态或者无法将前驱节点的状态修成Node.SIGNAL，那我们就将Node所代表的线程唤醒（真正唤醒），因为此线程本身就是阻塞的\n\n4、移到同步队列，此时可以说该线程有了获取锁的可能，因此可看做是唤醒了（留在条件队列是不可能获取锁的）","layout":null},"children":[]},{"data":{"id":"buo0b9lrig80","created":1559961817339,"text":"signal，移动一个节点移到同步队列末尾","note":"1、需要先获取锁\n\n2、唤醒队列中第一个未被取消的节点\n\n3、此处的唤醒跟signal一样，都是先放进同步队列末尾，只有当原队列末尾节点取消或无法改为signal时，才真正唤醒线程\n\n4、注意，无论结果是否被唤醒了，该节点都是在同步队列中，且未获取锁","layout":null},"children":[]},{"data":{"id":"buo8oiokps00","created":1559985424715,"text":"其他await方法","note":null,"layout":null},"children":[{"data":{"id":"buocx0096bk0","created":1559997373778,"text":"1、不响应中断 awaitUninterruptibly()","note":"1、全程不抛出中断异常，即使是被中断而唤醒的。也只是记录一下中断状态，随后线程再次挂起\n\n2、当前线程的节点保留在条件队列中，条件队列中的节点，只有在被signal后，可会被移到同步队列\n\n3、await中，中断的线程也会跳出循环，去竞争锁。此处则不可以。此方法必须是被signal后才能竞争锁。","layout":null},"children":[]},{"data":{"id":"buod7enefy00","created":1559998189294,"text":"2、设置超时时间（单位是纳秒） awaitNanos(long nanosTimeout)","note":"1、功能类似await，超过指定时间。则把节点从条件队列移到同步队列。\n\n2、挂起控制时间使用LockSupport.parkNanos(this, nanosTimeout); 与独占锁的超时实现一样\n\n3、如果设置的时间较短，spinForTimeoutThreshold，则不挂起线程，只是自旋。以减少挂起线程和唤醒线程所带来的时间消耗。\n\n4、对象锁的wait(0)是无限期等待，而此处的await（0）则是直接将节点移到同步队列，无需signa","layout":null},"children":[]},{"data":{"id":"buodlvhhyxs0","created":1559999323041,"text":"3、等价于方法2 await(long time, TimeUnit unit)","note":"1、等价于awaitNanos，只是时间单位可设置\n\n2、另外，返回值不一样，\nawaitNanos返回剩余超时时间，大于0表示提前被signal了\n\n此方法则使用布尔值，true表示被signa","layout":null},"children":[]},{"data":{"id":"buodo2ukpc00","created":1559999495797,"text":"4、超时，直至某时间点  awaitUntil(Date deadline)","note":"也跟其他超时方法作用一致\n\n没有自旋优化，因为使用此方法的，基本都是设置较长时间","layout":null},"children":[]}]}]},{"data":{"id":"buoey9e9lww0","created":1560003114800,"text":"LockSupport","note":"Lock中的阻塞、唤醒基本都是使用该类\n\nsynchronzed致使线程阻塞，线程会进入到BLOCKED状态，而调用LockSupprt方法阻塞线程会致使线程进入到WAITING状态。\n\n\n","layout":null},"children":[{"data":{"id":"buof017h0xc0","created":1560003253704,"text":"void park()：阻塞当期线程","note":"unpack、或者线程被中断可使线程唤醒","layout":null},"children":[]},{"data":{"id":"buof25uc4qg0","created":1560003420522,"text":"void parkNanos(long nanos)：超时返回","layout":null},"children":[]},{"data":{"id":"buof2ld17z40","created":1560003454304,"text":"void parkUntil(long deadline) 阻塞直至某时间点","layout":null},"children":[]},{"data":{"id":"buof2y2apx40","created":1560003481953,"text":"增加Object参数的重载方法","note":"以上三个方法都有增加一个对象的重载方法，如：\nvoid park(Object blocker)：\n\n该对象用来记录导致线程阻塞的阻塞对象，方便进行问题排查\n\n### 注\nsynchronzed阻塞了线程dump线程时都会有阻塞对象的描述，在java 5推出LockSupport时遗漏了这一点，在java 6时进行了补充\n\n\n\n","layout":null},"children":[]},{"data":{"id":"buof4t52kps0","created":1560003627965,"text":"void unpark(Thread thread):唤醒处于阻塞状态的指定线程","note":"synchornize 不能唤醒指定线程","layout":null},"children":[]}]}]}]}]},"template":"right","theme":"fresh-blue","version":"1.4.43"}