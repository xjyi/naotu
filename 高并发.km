{"root":{"data":{"id":"bx8b4ie4xs00","created":1569335836142,"text":"高并发"},"children":[{"data":{"id":"bx8b4r2ulns0","created":1569335855051,"text":"MQ"},"children":[{"data":{"id":"bx8b8mdmtt40","created":1569336158276,"text":"为什么要使用MQ","layout_right_offset":{"x":26,"y":-85},"note":"* 业务场景遇到什么技术挑战\n\t* 如果不用会很麻烦\n    \t* 但是用MQ就可以很好的处理\n        \n    * 适合场景\n    \t* 解耦\n        * 异步\n        * 削峰\n \n* 解耦\n\t* 系统对接多个系统\n    \t* 多套接口\n        \n    * 使用MQ，需要消息的就去获取\n    \t* 生产者消费者解耦\n        \n    * 场景\n    \t* 待补充\n\n\n* 异步\n\t* 一般互联网接口要求响应时间200ms以内\n    \t* 一个接口如果调用其他多个系统\n        * 总耗时可能长达1s，则性能太差\n    * 此时可以用MQ做异步处理\n    \t* 发送到MQ的时长很短，不需要等系统响应\n        \n        \n* 削峰\n\t* 5000QBS属于高并发（约100万用户）\n    \t* mysql一般能扛到2000个请求每秒\n        * 一万用户在线，50qbs也是正常的\n   \n   * 用户请求到达系统前，先用mq存储"},"children":[]},{"data":{"id":"bx95923cvjs0","created":1569420825780,"text":"优缺点","layout_right_offset":{"x":69,"y":-12},"note":"* 优点\n\t* 见“为什么使用”\n    \n* 缺点\n\t* 系统可用性降低\n    \t* MQ故障\n        * 解决:钉钉预警\n    \n    * 系统复杂性提高\n    \t* 数据发送了多次\n        * 解决：接口的幂等性（请求流水号）\n        \n        \n        * 消息丢了/顺序乱了\n    \n    * 一致性问题\n    \t* 某一个MQ执行失败\n    \n"},"children":[]},{"data":{"id":"bx8bdi39oq80","created":1569336540763,"text":"技术选型","layout_right_offset":{"x":59,"y":32.33333333333337},"note":"* 中小型公司用rabbitMQ\n\n* 大公司用rocketMQ\n\t* 性能各方面做的很好\n    * 大公司有能力维护rocket源码\n    \n\n* 大数据领域（实时计算）、数据采集\n\t* kafaka是业内标准，规范","expandState":"collapse"},"children":[{"data":{"id":"bx95styjopc0","created":1569422375358,"text":"activeMQ","note":"1. activeMQ\n\t* 单机吞吐量 万级\n    \t* 每秒处理数据量\n    * 时效性\n    \t* 毫秒ms\n    * 可用性 高\n    \t* 基于主从架构\n    * 消息可靠性\n    \t* 较低概率丢失数据\n        \n \n* 总结\n\t* 技术成熟\n    \t* 出了很久了（以前mq技术首选）\n        \n    * 缺点\n    \t* 有较低概率丢数据\n      \t* 官方社区不活跃\n        * 较少用在大规模吞吐的场景"},"children":[]},{"data":{"id":"bx95t04j1p40","created":1569422388781,"text":"rabbitMQ","note":"2. rabbitMQ\n\t* 单机吞吐量 万级\n    * 时效性（最大优点，低延迟）\n    \t* 微秒\n    * 可用性 高\n    \t* 基于主从架构\n        \n\n* 总结\n\t* 基于erlang开发\n    \t* 并发能力强，性能好，延时低\n        * 即消息在mq内部处理的时间少\n        * 此优点不明显\n        * 源码不好阅读\n    * 管理界面友好，中小型公司多使用\n    * 社区相对活跃"},"children":[]},{"data":{"id":"bx95t5gijco0","created":1569422400389,"text":"rocketMQ","note":"3. rocketMQ\n\t* 单机吞吐量 十万级\n    * 时效性\n    \t* 毫秒ms\n    * 可用性非常高\n    \t* 分布式架构\n\n* 总结\n\t* topic 增加到几百上千时\n    \t* 吞吐量有小幅下降\n    * 阿里开源，品质保障\n    \t* java语言\n    * 社区活跃度尚可\n    \n    * 公司假如不再维护，会有较大坏影响"},"children":[]},{"data":{"id":"bx95tdzbojk0","created":1569422418941,"text":"kafka","note":"\n4. kafka\n\t* 单机吞吐量 十万级（最大优点，吞吐量高）\n    \t* 一般配合大数据类的系统进行实时数据计算，日志采集\n        \n    * 时效性\n    \t* 毫秒ms\n        \n    * 可用性非常高\n    \t* 分布式架构，一个数据多个副本\n        * 少数机器宕机，不丢失数据，不会导致不可用\n        \n* 总结\n\t* topic较多时（上百）\n    \t* 性能下降较快\n        \n    * 只能支持简单的MQ功能\n    \t","layout_right_offset":{"x":15,"y":11}},"children":[]}]},{"data":{"id":"bx9zoi4swdc0","created":1569506669456,"text":"如何 保证消息队列的高可用","layout_right_offset":{"x":42,"y":52.66666666666663},"note":null},"children":[{"data":{"id":"bxa0caftac80","created":1569508533447,"text":"rabbitMQ","note":"* rabbitMQ\n\t* 非分布式\n    * 有集群\n    \t* 单机模式\n        * 普通集群模式\n        * [镜像集群模式]\n\n* 开启镜像集群模式\n\t* 管理后台新增一个策略\n    \t* 即该策略\n    * 可以要求数据同步到所有节点\n    \t* 也可以要求同步到指定数量节点\n        \n* 普通集群\n\t* 创建的 每一个队列，只会保存在其中一个节点（机器上）\n    \t* 该节点包含了元数据、实际的数据\n        * 元数据即是一些配置信息，如结构、名称等\n        * 其他节点上保存的是队列的元数据，以及有实际数据的节点位置\n    \n    \n    * 消费者去到没有数据的节点拿数据，则该节点会去有数据的节点拉取\n    \t* 可能导致mq内部大量数据传输\n    \n    \n    * 可以提高消费吞吐量\n    \t* 可用性几乎没有保障\n        * 存数据的节点宕机，则无法消费\n        \n* 镜像集群模式\n\t* 支持高可用\n    \t* 一个节点挂了，其他节点还有数据\n    * 队列的元数据、数据在每个节点上都有\n    \t* 写入数据的节点会对其他节点进行同步\n    * 非分布式\n    \t* 数据量达到单机承受布不了的话会有问题"},"children":[]},{"data":{"id":"bxa0hwtc5co0","created":1569508973975,"text":"kafka","note":"* 分布式\n\t* 每台机器（节点）有一个broker进程\n    \t* 每台机器+机器上的broker进程，就是kafka集群中的一个基点\n    \n    * 创建一个topic\n    \t* topic会被分成多个partition（每个只有一部分数据）\n        * partition可以存在不同的broker上\n        * 假如没有HA机制，一个节点挂了，数据就会丢失一部分\n\n\n\n* topic\n\t* 存储消息的一个逻辑概念\n    \t* 可认为是消息集合\n\n\n* HA机制（高可用机制）\n\t* kafka 0.8之后，提供了高可用机制\n    * replia副本机制\n    \t* 每个partition数据会同步到其他机器上，形成多个replia副本\n        \n        * 副本间会选举出一个leader，其他的为follower\n        \n        * 生产、消费都是跟leader打交道（其他不行），leader会同步数据到其他副本\n        \n        * 生产消费都是先全部同步成功，在返回ack给生产、消费者\n        \n    * 则一个节点挂了，数据还在，还能用\n    \t* 自动感知leader挂了，选举出新的leader"},"children":[]}]}]}]},"template":"default","theme":"fresh-green","version":"1.4.43"}