{"root":{"data":{"id":"92649cc62861","created":1560596028,"text":"基础"},"children":[{"data":{"id":"buu95txrgu00","created":1560596141145,"text":"数据结构"},"children":[{"data":{"id":"buu9609jvds0","created":1560596154918,"text":"map"},"children":[{"data":{"id":"buu963pxdco0","created":1560596162439,"text":"hashmap","expandState":"expand"},"children":[{"data":{"id":"buubl2pqlk80","created":1560602977933,"text":"结构：数组+链表+红黑树","note":"1. 数组\n  * 使用数组，是因为数组能够快速查找\n\n2. 每个数组挂一个链表\n  * jdk1.8之后，链表大于8后转化为红黑树\n  * 链表的出现是为了解决hash冲突\n  * 红黑树的出现是为了将链表的查找时间复杂度O（n降为O（logn）\n \n3. 数组（或链表）里，放的是一个node节点，包含一对键值对"},"children":[]},{"data":{"id":"buubwshmtts0","created":1560603896045,"text":"数据插入、查找（先hashcode，再hash，最后位运算）","note":"1.  获取key的hashCode()\n\n   * 该方法是本地方法，返回一个整数值\n  \n2. 调用hash()\n \n   * 对hashcode的低位进行扰动，映射成数组下标时可以更均匀\n   * 值传入Node节点进行记录，下次不重新计算\n   \n3. 与运算\n  * hash后的整数与数组长度-1 进行与运算，获得角标\n  * 数组长度-1 = 角标最大值","expandState":"expand"},"children":[{"data":{"id":"buu969wtwko0","created":1560596175917,"text":"hash（）详解","note":"hash function（即散列函数）\n\n扰动函数\n return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n   * 将key的高16位与低16位进行^异或运算，使低位保留部分高位的特征"},"children":[]},{"data":{"id":"buvu5j9trvk0","created":1560756921194,"text":"put（）","note":"putVal其他参数\n  * onlyIfAbsent 默认false，会覆盖相同key的值\n  * evict：当前是否处于构造函数中\n  \n1.调用putVal\n判断table变量是否为空，空则调用resize（）初始化table\n\n  * table初始化在put而不在构造函数\n  * 如果是传入一个map的构造函数，则在构造函数里面调用的putVal\n\n2.当前下标的数组无节点，直接创建新节点\n\n3.当前数组中的元素key即是目标key，取出该元素（随后替换值）\n  * hash相同，并且==或equals成立\n\n4.当前节点判断是红黑树节点\n  * 红黑树节点处理（待补充）\n  \n5.当前是链表结构\n  * 链表逐个元素遍历，看是不是当前节点\n  * 已经到了末尾还找不到，则新建节点，插到链表末尾。如果已经超过8，链表变成红黑树\n  * 未到末尾找到了，则取出该元素（准备改该值）\n\n最后插入元素后，判断是否需要扩容\n  * 加入新节点后，总结点数大于临界数threshold 则调用resize扩容\n  * 注意，threshold的值是初始数组大小乘以影响因子，后续都是原值左移一位\n  * 但是判断是否需要扩容是全部节点数，不是数组大小\n\n\n"},"children":[]}]},{"data":{"id":"buuccc0gexc0","created":1560605114004,"text":"数组大小与扩容","note":"1. map总数已经达到数组长度的3/4，就会扩容\n\n2. 链表变树时，发现数组大小小于64（默认），则扩容，暂不变树\n  \n3. 开始默认是16，每次扩容是翻倍\n\n4. 大小始终是2的N次方\n  * 因为要跟角标最大值进行与运算，只有数据是2的N次方时，角标最大值的二进制才都是1，才能保证，只要hash出来的值是均匀的，得出来的角标也是均匀的\n  \n5. 使用自定义大小的hashmap，会使用tableSizeFor获取大于等于该值的2^N数字\n"},"children":[{"data":{"id":"buudui56l1c0","created":1560609359016,"text":"tableSizeFor（initialCapacity）","note":"获取一个大于或等于该传入值的2的N次方的数\n  * 为什么一定要是2^N，见前文\n  * 如何实现\n```\n  int n = cap - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n```\n\n1. 计算使用的值一定是2^N-1（二进制全是1）\n所以返回的一定是n+1，不先-1，则如果是刚好就是2^N，则变成2倍\n\n2. 通过或运算，将当前值后面的二进制位全部变成1，最后加1（表示size）\n\n3. n |= n >>> 1; n=n|n >>> 1,则n的最高位后面的位肯定也变成1，如此类推，int最大32，则使用16后完成。"},"children":[]},{"data":{"id":"buvnj5h7qww0","created":1560738240495,"text":"resize()","note":"1. 初始化table或者扩容调用\n  * table：Node数组（即数组+链表中的数组）\n  * threshold：自定义大小的hashmap，计算出来的2次幂，存放在此变量，resize时使用\n  \n  \t\t* 自定义的，threshold使用后，更新为：数组大小 乘于 影响因子（作为扩容临届数）\n        * 非自定义的，0 直接更新按照上面公式更新\n        * 扩容的，左移一位（乘以2）\n\n2. 对于扩容，是new一个新的数组，并将原数组，及其链表数据（红黑树）进行重新hash，放进新数组中。\n\n  * 扩容，重新计算下标位置，位运算的2^N-1只相差了一个高位，因此重新算的结果要么是原来的位置j，或者j+oldCap\n  \n  * 只有一个元素：扩容后的数组肯定只有一个元素。直接重新计算角标，放进新数组\n  * 链表：由上可知，一个链表拆分后，只会在原位置j，或者j+oldCap两种可能。使用(e.hash & oldCap) == 0 进行区分 \n  \n      * 2^N-1与2^(N+1)-1相差的高位就是2^N的1的位置"},"children":[]}]},{"data":{"id":"buucm388w6w0","created":1560605878526,"text":"注","note":"HashMap中key值可以为null, 且null值一定存储在数组的第一个位置."},"children":[]},{"data":{"id":"buwws5n9y200","created":1560865896085,"text":"红黑树相关","expandState":"expand","note":"红黑树特点\n  * 根节点、叶子节点都是黑色\n  * 不能有连续的红色节点（叶子到根的所有路径）\n  * 任意节点到每个叶子节点，包含相同的黑色节点\n  \n由上，\n  * 可以有连续的黑色节点（只要保证第三点即可\n  * 左右两兄弟节点可以颜色不同"},"children":[{"data":{"id":"buwwsc0pgvk0","created":1560865909958,"text":"节点结构","note":"TreeNode：是Node的子类的子类\n父节点\n左节点\n右节点\n上一个节点： 原链表中的前一个节点\n颜色标记"},"children":[]},{"data":{"id":"buwwv9ii17s0","created":1560866139596,"text":"treeifyBin(tab, hash);  put操作。 链表转化为红黑树前处理","note":"1.先将链表每个Node节点转为红黑树的TreeNode\n  * 此时只有原来的信息（无左右节点等）\n  \n2.将单向链表转化为双向链表\n\n3.调用hd.treeify(tab);进行树化\n"},"children":[]},{"data":{"id":"buwx0kp5rq80","created":1560866555764,"text":"hd.treeify(tab); 链表树化","note":"链表树化\n1.先将第一个节点设置为根节点\n\n2.第二个节点开始，逐个处理\n  * 从根开始，逐个根据hash值对比\n  * 左小右大，比当前节点小，则与当前节点的左节点继续比较（右同理），直至找到一个空节点\n  * hash相同用conpareTO计较，还相同则比较类名，最后用对象默认hashcode比较\n  * 将当前节点放进空节点\n  * balanceInsertion(root, x);将树平衡\n  \n3.moveRootToFront(tab, root);确保树的根节点是数组的第一个节点"},"children":[]},{"data":{"id":"buwxgai3cbc0","created":1560867787395,"text":"balanceInsertion(root, x) 平衡 树的节点","note":"1.节点都是根据hash值比较，直至找到一个空位置\n2.节点统一初始化为红色\n\n插入到指定位置后，只要不影响树的平衡，则无需处理\n * 插入节点的父节点是黑色，无需处理，红色不影响平衡\n * 插入节点的父节点是根节点，同上（根是黑色）"},"children":[{"data":{"id":"buxeq7vzw3c0","created":1560916524216,"text":"左旋","note":"目标\n  * 一个节点左旋，就是和自己的右子节点换位置，成为右子节点的左子节点\n  * 原右子节点的左子节点不为空，则该子节点成为当前节点的右子节点\n\n源码\n  * 右子节点的左子节点赋值给当前节点的右子节点引用（并同时修改移动的此节点父节点引用）\n  * 当前节点的父节点引用，赋值给右节点的父节点引用（该父节点为空，说明右子节点成为根，则修改根引用，将颜色改成黑色）\n  * 父节点不为空，则赋值给原右节点父节点引用（判断当前节点是父节点的哪个子节点，并将改子节点引用指向原右子节点）\n  * 最后才是将当前节点赋值给原右子节点的左子节点（并同时设置双向的引用指向）","image":"http://kityminder-img.gz.bcebos.com/a99f1437596ebb37951906a9a9d08a22d95d67bb","imageTitle":"","imageSize":{"width":200,"height":88}},"children":[]},{"data":{"id":"buxfbwnv8ag0","created":1560918223791,"text":"右旋","image":"http://kityminder-img.gz.bcebos.com/abe7bb4e034262ec6bfd2a1f671d371697e6a2a0","imageTitle":"","imageSize":{"width":200,"height":91},"note":"右旋\n  * 跟自己的左子节点换位置\n  * 旋转都是很自己的子节点进行换位置\n\n源码\n  1. 与左旋一样，先处理左子节点的右子节点\n  2. 再将当前节点的父节点给到原左子节点的子节点\n  3. 最后处理当前节点与原左子节点的关系\n\n  "},"children":[]}]},{"data":{"id":"buwxgnpymvk0","created":1560867816169,"text":"moveRootToFront(tab, root); 确保树的根节点是数组的元素","note":"1.变成红黑树后，原链表结构仍存在\n  * 并且链表结构是双向链表\n  * 原顺序保持不变\n  * 链表的顺序其实并无太大意义，因为是根据put的顺序进行排序\n\n2.将红黑树的root节点移到链表首位\n  * 数组中的元素也是变成root\n  * 原root的上下节点直接连起来\n  * root为第一位，原first变成第二位，root的prev设为null\n  \n3. 校验更改后的结构是否满足红黑树和双链表的特性（hashmap非线程安全）"},"children":[]},{"data":{"id":"buza1ymh6x40","created":1561106458783,"text":"节点删除","note":"节点的删除\n  * 先查找出该需要删除的节点\n  * 将原来的双向链表中的引用去掉\n  * 树节点太小，直接把树拆了\n  * 平衡。"},"children":[]}]},{"data":{"id":"bv60lo7925c0","created":1561790711975,"text":"与1.7区别","note":"1、1.7使用的是entry，1.8是Node节点\n\n\n2、1.7 的链表是头插法\n\t* 新来的节点直接放在数组。原节点成为新节点的next\n    \n    \n3、 1.8 的链表是尾插法\n\t* 超过8，触发变成红黑树。1.8才有红黑树\n    * 当然变成红黑树有条件，如果数组长度不及64，则只是扩容，不变树\n   "},"children":[]}]},{"data":{"id":"buu96eikzhs0","created":1560596185939,"text":"ConcurrentHashmap"},"children":[{"data":{"id":"bv60nwjh23k0","created":1561790886857,"text":"1.7 结构 segment、hashEntry数组","note":"1. ConcurrentHashmap中包含了一个segment数组\n\t* 共有2^N个segment（默认16）\n    \n2. 每个segment里面有一个HashEntry数组    \n\t* HashEntry数组元素下面会挂一个链表，相当于一个1.7版本的Hashmap\n    * 继承ReentrantLock来支持并发操作\n    * segment间的写操作是可以并发的，降低了锁的粒度\n\n3. 只有对同一个segment进行写才会阻塞\n\t* 读操作不加锁\n    * HashEntry数组是volatile修饰的，读取的时候会回获取主存中的最新值"},"children":[{"data":{"id":"bv622f9lbo00","created":1561794845826,"text":"同时操作同一个segment的put","note":"segment的put\n\t* trylock获取锁，获取成功则执行put逻辑\n    * 获取不了，继续获取64次（机器只有1核则一次）\n    * 调用ReentrantLock锁的lock()挂起线程\n    \n    "},"children":[]},{"data":{"id":"bv62xy2skc00","created":1561797316063,"text":"size统计","note":"1. 统计每个segment的个数，并统计modCount次数\n\t* modCount：数据变化操作的次数\n2. 两次统计一样，则结束，否则继续。最多统计3次\n\n3. 超过3次则每个segment加锁"},"children":[]}]},{"data":{"id":"bv7qgi4g7v40","created":1561965215738,"text":"1.8 结构 Node + CAS + Synchronized","note":"1. ConcurrentHashmap 的数组中，红黑树类型的节点是 TreeBin\n  * TreeBin 中封装了TreeNode\n  * TreeNode 的hash域才是真正的hash值\n  * TreeBin的hash域是-2，可根据此判断为树节点\n\n2. 指定ConcurrentHashmap大小的构造，与hashmap一样，返回一个大于等于传入值的数"},"children":[{"data":{"id":"bv7u11a3ptc0","created":1561975288052,"text":"initTable初始化","note":"1. sizeCtl 初始化时是数组大小\n\t* 初始化后相当于临界数threshold\n\n2. cas保证只有一个线程操作初始化\n\n3. 其他\n\t* 可参考源码的实现方式 :n - (n >>> 2)   \n    右移两位，相当于除以4，减去剩3/4"},"children":[]},{"data":{"id":"bv7r7yzeefc0","created":1561967368271,"text":"put 插入","note":"1. 插入时，数组当前为空。不加锁，使用cas插入。\n  * 不成功则下一次循环（下一次判断是否为空等）\n\n2. hash=MOVED 正在扩容的话，调用helpTransfer，协助其他线程进行扩容\n\t* 数组的Node之间的扩容是独立的\n\n3. 数组不为空，且数组的Node节点的hash域不等于MOVED (移动状态,当前正在扩容)\n  * 加锁插入链表或红黑树\n  * Synchronized加锁，使用数组的这个Node节点对象"},"children":[]},{"data":{"id":"bv8kfnzocf40","created":1562049783444,"text":"transfer 扩容","note":"1. 数组逐个Node处理\n\t* 为空，设置为特殊节点forwardingNode（hash是MOVED，表示不用处理或已处理）\n    * 该节点的hash是MOVED，跳过。\n    * 不为空的，为链表或者是红黑树\n    \n2. 对节点加synchornize锁，拆分链表及红黑树\n\t* 拆分逻辑跟hashmap差不多，拆完后的将在新数组的原位置x，或n+x（x是原数组大小） \n    * 处理完后，原数组节点设置为forwardingNode，表示已处理。\n    * 处理好的在新数组。标记在旧数组"},"children":[]},{"data":{"id":"bv8ngm4un5k0","created":1562058321097,"text":"size","note":"1. size的统计\n\t* 统计baseCount，以及CounterCell数组中的数据之和\n    * 这种方法将竞争数据按照线程的粒度进行分离\n    相比所有竞争线程对一个共享变量使用CAS不断尝试在性能上要效率多了"},"children":[{"data":{"id":"bv8o6dfe0e00","created":1562060339611,"text":"CounterCell数组","note":"1. 每个线程都会通过ThreadLocalRandom.getProbe() & m寻址找到属于它的CounterCell，然后进行计数。\n\n2. ThreadLocalRandom是一个线程私有的伪随机数生成器，每个线程的probe都是不同的\n\t* 这点基于ThreadLocalRandom的内部实现，它在内部维护了一个probeGenerator，这是一个类型为AtomicInteger的静态常量，每当初始化一个ThreadLocalRandom时probeGenerator都会先自增一个常量然后返回的整数即为当前线程的probe，probe变量被维护在Thread对象中\n    \n3. 可以认为每个线程的probe就是它在CounterCell数组中的hash code"},"children":[{"data":{"id":"bv8ois31qj40","created":1562061311887,"text":"数组大小与碰撞","note":"1. 初始化为2，每次扩容乘以2，最大不超过机器的CPU数量\n\n2. 数组太小，容易多个线程造成碰撞。此时使用cas操作\n\n3. cellsBusy是一个只有0和1两个状态的volatile整数"},"children":[]}]}]}]},{"data":{"id":"bv7qv0kk1b40","created":1561966352993,"text":"注","note":"key、value 都不允许为空"},"children":[]}]}]},{"data":{"id":"buu96bfyneg0","created":1560596179250,"text":"list"},"children":[]}]}]},"template":"right","theme":"fresh-blue","version":"1.4.43"}