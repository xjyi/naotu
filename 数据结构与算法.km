{"root":{"data":{"id":"bxcash4fucw0","created":1569741132836,"text":"数据结构与算法","note":"1. 广义\n\t* 数据结构\n    \t* 指一组数据的存储结构\n    * 算法\n    \t* 操作数据的一组方法\n\n2. 狭义\n\t* 某些著名的数据结构和算法\n    \t* 比如队列、栈、堆、二分查找、动态规划\n        * 这些都是前人智慧的结晶"},"children":[{"data":{"id":"bxocsqnvixs0","created":1570965515302,"text":"复杂度分析","note":"1. 通过统计，监控等获取算法的执行时间及占用内存\n\t* 叫事后统计法\n    \t* 依赖测试环境，如硬件。还有数据规模等\n    * 因此不准确","expandState":"collapse"},"children":[{"data":{"id":"bxoctcl8pe00","created":1570965563032,"text":"时间复杂度","note":"* 大O时间复杂度\n\t* 表示代码执行时间随数据规模增长的变化趋势\n    * 也叫渐进时间复杂度\n    \t* 简称时间复杂度\n        \n        \n* 时间复杂度分析\n\t* 大O的复杂度表示方法，表示的是一种变化趋势\n    \t* 因此一般会忽略常量、低阶，系数等\n        * 只记录最大阶的量级即可\n        \t* 如循环执行次数最多的一段代码\n            \n        \n        \n* 加法法则\n    * 总复杂度等于量级最大的那段代码的复杂度\n        * 常量级别的代码（与n五无关的），即使执行上万遍，复杂度都是 O(1)\n        * 因为对变化趋势没有影响\n        \n\t* 如代码的复杂度里有O(n),O(n^2)， 则只看最大的O(n^2)\n        \n  \n* 乘法法则\n    * 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n    \t* 如O(n) 与 O(n^2) 的乘积是O(n^3)\n        \n        \n* 多个数据规模, 即数据规模不止一个\n\t* 如 m n\n    \t* 由于两个数字都是变化的\n        * 因此复杂度根据两数据规模一起决定\n        \n        * 如O(m+n) , O(m* n) 等\n   "},"children":[{"data":{"id":"bxodo0eh8a00","created":1570967965791,"text":"复杂度量级","note":"* 多项式量级(按数量级递增)\n\t* 常数阶\n    \t* O(1)\n        * 执行了很多行，只要跟数据规模没关系，就是O(1)\n        \n    * 对数阶\n    \t* O(logn)\n        \n    * 线性阶\n    \t* O(n)\n        \n    * 线性对数阶\n    \t* O(nlogn)\n        \n    * 平方阶，立方阶...k次方阶等\n    \t* O(n^2) O(n^3)\n\n\n\n\n\n\n* 非多项式量级\n\t* O(2^n)和O(n!)\n    \t* 指数阶，阶乘阶\n\n        \n    * 是非常低效的算法\n    \t* 数据规模越来越大时，非多项式量级算法的执行时间会急剧增加"},"children":[]},{"data":{"id":"bxoe1xbbt5s0","created":1570969056168,"text":"对数阶","note":"* O(logn)\n\t* 对数阶的复杂度表示方法中\n    \t* 忽略对数的底\n     \n\t* 因为任何底数的对数\n    \t* 都可以转化为：其他底数的对数 乘以 一个常数\n        * 见有道笔记，此处不好表示底数\n        \n        \n        \n* 对于线性对数阶O(nlogn)\n\t* 相当于O(logn)的代码循环执行了n遍\n    \t* 乘法法则\n        \n    * 归并排序、快速排序的时间复杂度都是O(nlogn)"},"children":[]},{"data":{"id":"bxofdyorb8g0","created":1570972820637,"text":"最好、最坏情况时间复杂度","note":"* 最好\n\t* 在最理想的情况下，执行这段代码的时间复杂度\n \n* 最坏\n\t* 在最糟糕的情况下，执行这段代码的时间复杂度"},"children":[]},{"data":{"id":"bxofe9y9uuw0","created":1570972845157,"text":"平均情况时间复杂度","note":"* 通常是将每种情况的耗时相加\n\t* 除以N种情况的个数\n    \t* 得到一个平均值\n        \n        \n* 但是，不算上各种情况的概率是不准确的\n\t* 因此，应该每种情况单独算上出现的概率\n    \t* 得到加权平均值\n        \n\n* 因此，也叫\n\t* 权平均时间复杂度\n    \t* 或者期望时间复杂度\n   \n   \n   \n* 注\n\t* 一般使用一个复杂度就可以了\n    \n    * 只有同一块代码在不同的情况下，时间复杂度有[量级的差距]\n    \t* 我们才会使用这三种复杂度表示法来区分\n\t"},"children":[]},{"data":{"id":"bxofedd85ls0","created":1570972852591,"text":"均摊时间复杂度","note":"* 相比前面的复杂度分析，使用场景更加特殊、更加有限。\n\n\n* 摊还分析法\n\t* 通过摊还分析得到的时间复杂度\n    \t* 叫均摊时间复杂度\n    \n    * 能够通过摊还分析法处理，就不用使用加权平均去算，会更加简便\n     \n     \n     \n* 使用场景：对于一些特殊的复杂度分析\n\t* 例如，经过n个的O(1) 操作之后\n    \t* 有一个 O(n) 的操作\n    * 并且是有规律的，有一定时序关系的\n    \n    * 则可以将该次O(n) 的操作，均摊到每个O(1)操作\n    \t* 总体复杂度就是O(1)\n      \n      \n      \n* 在能够应用均摊时间复杂度分析的场合\n\t* 一般均摊时间复杂度就等于最好情况时间复杂度\n    \n    * 可以认为\n    \t* 均摊时间复杂度就是一种特殊的平均时间复杂度"},"children":[]}]},{"data":{"id":"bxoctj3oixk0","created":1570965577208,"text":"空间复杂度","note":"* 渐进空间复杂度\n\t* 表示算法的存储空间与数据规模之间的增长关系\n    \n* 常见的空间复杂度就是O(1)、O(n)、O(n^2)  \n\t* 如对于传入的n个参数\n    \t* new对应大小的数组\n        * 则空间复杂度就是O(n)\n    ","layout_right_offset":{"x":-22.499999105930385,"y":95.83332952525899}},"children":[]}]},{"data":{"id":"bxp1qn1ya480","created":1571035878465,"text":"数组","note":"* 数组（Array）\n\n1. 是一种线性表 数据结构\n    * 数据排成像一条线一样的结构\n    \n    * 每个线性表上的数据，最多只有前后两个方向\n        * 链表、队列、栈等也是线性表结构\n        * 二叉树、堆、图等是非线性表\n        \n2. 它用一组连续的内存空间，来存储一组具有相同类型的数据。\n\n\n\n","expandState":"collapse"},"children":[{"data":{"id":"bxp20zls5pc0","created":1571036689428,"text":"读","note":"* 数组读比较快\n\t* 是因为数据可以进行随机访问\n    \t* 基于连续的内存空间和相同的数据类型\n        * 首地址 + 角标 * 每个元素大小\n    * 数组支持随机访问，根据下标随机访问的时间复杂度为O(1)\n    \t* 注意不能说数组查找时间复杂度为O(1)\n        \n        \n* 根据寻址公式，所以下标从0开始 更加简便，无需做减1操作\n\t* 角标相当于一个偏移量\n    * 而java等语言沿袭了C语言中的设计，所以下标从0开始\n    \n    \n* 关于二维数组\n\t* 猜测地址是从先按照列，再到行\n    \n    * 对于 m * n 的数组，a [i][j] (i < m,j < n)的地址为：\n\n\t* address = base_address + ( i * n + j) * type_size\n    "},"children":[]},{"data":{"id":"bxp2121igjk0","created":1571036694732,"text":"插入、删除","note":"* 插入\n\t* 随机插进一个数组的一个位置，并且该位置后的元素都往后移动一位\n    \t* 时间复杂度为O(n)\n        * 如插入一个有序结构\n        \n    * 不需要移动\n    \t* 如直接将该位置元素放到最后\n        * 时间复杂度：O(1) \n        * 快排中有使用到这种思想\n        \n        \n        \n* 删除\n\t* 删除数组中随机一个元素，并移动其他元素，保证内存的连续性\n    \t* 时间复杂度：O(n)\n        \n    * 如果不需要保证内存连续性\n    \t* 如只标记为已删除，待空间不够再真正删除\n        * 时间复杂度猜测为O(1)\n        * 与JVM的标记清除算法思想类似"},"children":[]},{"data":{"id":"bxp2lkd4gbs0","created":1571038301900,"text":"与容器比较","note":"* 容器，如ArrayList等\n\t* 优点\n    \t* 可以将很多数组操作的细节封装起来，如：支持动态扩容\n        * ArrayList是按照1.5倍数动态扩容\n        \t* 扩容操作涉及内存申请和数据搬移，如果事先能确定需要存储的数据大小，最好在创建ArrayList的时候事先指定数据大小。\n        \n        \n        \n      \n      \n      \n* 数组使用场景\n    * ArrayList无法存储基本类型，而自动装箱、拆箱有一定的性能消耗\n        * 所以特别关注性能，或者希望使用基本类型，就可以选用数组\n        \n    * 数据大小事先已知，且要做的操作简单,用不到ArrayList的大部分方法\n    \t* 则可以使用数组\n    \n    * 另外多维数组时，Object[][]\n    \t* 看起来更加直观（个人喜好）\n\n\n\n\n* 一般使用容器就足够了，除非想把性能做到极致\n    \t\n        "},"children":[]}]},{"data":{"id":"bxp5b1zpio80","created":1571045941595,"text":"链表","note":"* 对比数组\n\t* 数组需要连续的内存\n\t\t* 链表不需要\n        \n    * 复杂度刚好相反\n    \t* 数组插入O(n),查询O(1)\n        * 链表插入O(1),查询O(n)\n        \n        \n        \n    * 数组实现上使用的是连续的内存空间\n    \t* 可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高\n        \n        * CPU每次从内存读取数据并不是只读取那个特定要访问的地址\n        \t* 而是读取一个数据块\n            * 下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取\n     \n     \n     \n    * 数组扩容，需要将数据重新复制一份。费时","expandState":"collapse"},"children":[{"data":{"id":"bxp5bct6r7s0","created":1571045965145,"text":"关于内存淘汰策略","note":"* 先进先出策略FIFO（First In，First Out）\n\n* 最少使用策略LFU（Least Frequently Used）\n\n* 最近最少使用策略LRU（Least Recently Used）\n\t* linkedHashMap就是利用双向链表来实现的LRU"},"children":[]},{"data":{"id":"bxp5f7ahxbs0","created":1571046266588,"text":"各种链表","note":"\n        \n        \n* 单链表\n\t* 每个链表节点\n    \t* 除存储数据外\n        * 还有一个后继指针next，记录下一个节点的地址\n        \n    * 头结点记录链表的基地址\n    * 尾结点指向空地址null\n    \n    * 删除操作的时间复杂度\n    \t* 不需移动其他节点，因此是O(1)\n    * 查找\n    \t* 无法使用寻址公式\n        * 因此时间复杂度：O(n)\n        \n        \n* 循环链表\n\t* 尾节点的next指向头节点\n    \n* 双向链表\n\t* 除了一个next后继节点\n    \t* 还有一个prev前驱节点\n        \n    * 占用更多空间，但是更加灵活\n    \t* 反正就是可以获取前面的节点，不需要从头开始遍历\n        \n* 双向循环链表\n\t* 如描述，双向，且是环状","layout_right_offset":{"x":8.499997317791099,"y":3.8333333002196355}},"children":[]},{"data":{"id":"bxpc76i3f140","created":1571065385726,"text":"单向链表判断是否回文","note":"1. 使用快慢指针定位链表中间节点\n\t* 快指针一次走两步\n    * 慢指针一次走一步\n    \t* 则快指针走完时，满指针走到中间\n        * 注意判断奇偶数，可根据快指针进行判断\n\n2. 慢指针走的时候，将前半部分反序\n\n3. 前后半部分比较，判断是否为回文\n\n4. 前半部分逆序复原\n\n5. 时间复杂度O(n), 空间复杂度O(1)\n\n* 代码见github"},"children":[]},{"data":{"id":"bxq4lvas1dc0","created":1571145527879,"text":"算法代码技巧","note":"1. 哨兵节点\n\t* 在链表的头部等边界地方，设置哨兵\n    \t* 可以将边界的特殊处理变成普通处理\n        \n    * 如带头链表的头即为哨兵 \n    \t* 则所有节点的插入删除逻辑都一样了\n        \n    * 又如：在数组中找值为x的节点\n    \t* 先判断数组尾部的的是否符合\n        * 不符合的话，替换尾部节点为目标x\n        \t* 符合直接返回\n        * 从头开始遍历数组，直至找到x\n        \t* x不是最后一个，则找到\n          \t* x是最后一个，表示数组中没这个元素\n        \n        * 优化点：无需判断数组是否角标越界。直接判断是否等于x即可\n        \t* 大数据量中，少一个判断也是很重要的\n            * 当然平时不要这样写。。。\n   \t"},"children":[]}]},{"data":{"id":"bxremdslruw0","created":1571275339195,"text":"栈","note":"* 栈是一种 操作受限 的线性表\n\t* 先进后出，后进先出\n    \t* 只允许一端插入、删除数据\n        \n        \n* 相比链表、数组，栈带来的只有限制\n\t* 但是在特定场景，栈能够满足需求\n    \t* 同时更加可控，不容易出错\n        \n      \n* 数组实现的栈\t\n\t* 叫：顺序栈\n\n* 链表实现的栈\t\n\t* 叫：链式栈\n    \n    \n    \n* 栈 操作的时间、空间复杂度\n\t* 时间复杂度\n    \t* O(1) 因为每次都只操作顶部的一个元素\n    \n    * 空间复杂度\n    \t* O(1) 只需一两个临时变量存储空间\n        * 动态扩容的顺序栈，到达某一临界大小时扩容，迁移数据到更大的内存\n        \t* 此时可用摊还分析法，将数据搬移工作均摊到每一次入栈操作\n            * 时间复杂度还是O(1)\n\n\n* 注意：\n\t* 存储的空间都是一个大小为n的数组或链表，不代表空间复杂度就是O(n)\n        * 因为这个空间是必须的，无法省掉\n        * 我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间","expandState":"collapse"},"children":[{"data":{"id":"bxrf07ku5pk0","created":1571276422763,"text":"栈的应用","note":"1. 函数调用栈\n\t* 每进入一个函数\n    \t* 就会将临时变量作为一个栈帧入栈\n    * 当被调用函数执行完成，返回之后\n    \t* 将这个函数对应的栈帧出栈\n        \n\n2. 表达式\n\t* 传入一串表达式，如:3+ 5* 4-2\n    * 编译器通过两个栈实现\n    \t* 一个保存操作数的栈\n        * 一个是保存运算符的栈\n        \n    * 从左往右遍历表达式\n    \t* 遇到数字，压入操作数栈\n        * 遇到运算符\n        \t* 与运算符栈顶的元素比较\n    * 比较规则\n    \t* 先确定所有的优先级\n        * 当前比运算符栈顶的元素优先级高，压入栈顶\n        * 等级更低或者等级相同，取出栈顶运算符先运算\n        \n        \n        \n3. 检查各种括号()[]{}等是否匹配\n    * 遍历表达式。遇到坐括号就压入栈中\n    \t* 遇到右括号就取出栈顶元素进行匹配\n        * 全部能匹配则通过\n        \n\n4. 浏览器的前进后退\n\t* 使用2个栈\n    \t* 点后退，就将左栈栈顶页面移到右栈\n        * 点前进，就将右栈栈顶元素移到左栈\n        * 点了其他页面，清空右栈\n    \n"},"children":[]}]},{"data":{"id":"bxrfxglglm00","created":1571279028409,"text":"队列","note":"* 也是操作受限的线性表数据结构\n\t* 先进先出\n    \n* 数组实现的队列\n\t* 顺序队列\n    \n* 链表实现的队列\n\t* 链式队列\n    \t* 实现逻辑相对简便\n    \n    \n","expandState":"collapse"},"children":[{"data":{"id":"bxsasicvh1s0","created":1571366094829,"text":"顺序队列实现","note":"* 顺序队列的实现\n\t1. 正常的数组，取出head元素后，head指针往前一步\n    \t* 会导致即使数组中有空位，也无法继续插入数据\n    \n    \n    2. 解决方案\n    \t* 当数据入队时已经满了，则触发数据搬移\n        * 每个元素一次性移动n位（直接赋值，n是角标是0与head的距离）\n        \n        \n    3. 循环队列解决方案\n    \t* 数组的最后元素指向head，则形成环状\n        * 无需数据搬移，性能更好\n        \n        * head 与 tail之间留一个空位不存数据\n        \t* 此处猜测是沿用非环状数组的用法，但是非环状数组会在满了之后，也利用最后一个空位\n        \n        * 队空的判断不变，都是head==tail\n\n\n\n* 队满的条件：(tail+1)%n=head\n\t* n是数组大小，tail是从零开始，因此tail+1不可能比n大。\n    \t* 相当于tail + 1 = head\n        \n    * 使用取模的意义在于临界点的判断\n    \t* tail是最大角标n-1，head是0，此时 n-1+1%n=0\n        * 即完成一圈就将数字重置为0，也就刚刚好是取模的用法\n        \n    * head、tail的移动都需要按照此公式"},"children":[]},{"data":{"id":"bxsb5yd7u940","created":1571367148413,"text":"关于阻塞队列","note":"* 一般无界的队列，就是链式队列实现的"},"children":[]}]},{"data":{"id":"bxsbdf7bmpk0","created":1571367733611,"text":"递归","note":"* 递归需要满足的三个条件\n\t* 一个问题的解可以分解为几个子问题的解\n    \n    * 这个问题与分解之后的子问题，除了数据规模不同\n    \t* 求解思路完全一样\n    \n    * 存在递归终止条件\n    \n    \n* 因此递归的关键在于\n\t* 写出递推公式\n    * 找到终止条件\n    \n    \n* 思维误区\n\t* 不要尝试去思考、层层分解每一层子问题，子子问题的关系\n    \t* 只考虑当前问题与子问题的关系即可（算出递推公式）\n      \n      \n\n","expandState":"collapse"},"children":[{"data":{"id":"bxsbnzamu600","created":1571368560988,"text":"递归的问题","note":"* 警惕栈溢出\n\t* 解决：定义全局变量，每执行一次+1，超过一定深度直接报错返回\n    \t* 估算的阈值不一定准确，因为跟当前线程剩余栈空间大小有关\n        * 因此不太实用，一般是深度较少的时候才使用\n        \n    * 因为递归调用一次就会在内存栈中保存一次现场数据\n    \t* 因此空间复杂度也会变大\n        * 如电影院的逐行递归，空间复杂度是O(n)\n        \n    \n        \n        \n        \n* 重复计算\n\t* 递归可能造成大量重复计算\n    \t* 如递归分成左右2子问题，子问题间可能会有重复\n        \n    * 解决\n    \t* 使用map存起来，递归调用前判断\n        \n* 递归的函数调用较多，数量大时时间效率较低"},"children":[]},{"data":{"id":"bxsbyvd6d6g0","created":1571369414441,"text":"优缺点","note":"* 优点\n\t* 递归代码的表达力很强，写起来非常简洁\n    \n* 缺点\n\t* 空间复杂度高、有堆栈溢出的风险\n    * 存在重复计算、过多的函数调用会耗时较多等问题\n    \n    \n    \n* 所有的递归代码都可以改为迭代循环的非递归写法\n\t* 因为递归本身就是借助栈来实现的\n    * 只不过我们使用的栈是系统或者虚拟机本身提供的\n    \t* 如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程\n        * 这样任何递归代码都可以改写成看上去不是递归代码的样子。\n\n\n* 一般思路是从底部结束条件往前迭代\n\n* 但是这种思路实际上是将递归改为了“手动”递归\n\t* 本质并没有变，\n\t* 而且也并没有解决前面讲到的某些问题，[徒增]了实现的复杂度。\n    \n    \n* 数据规模大，就要用这种方式了，避免递归导致栈溢出"},"children":[]},{"data":{"id":"bxsfkqgd6a00","created":1571379591091,"text":"递归断点","note":"* 对递归的值打日志\n\t* 并且结合 条件断点 使用\n    \t* idea断点->右键，设置条件"},"children":[]}]},{"data":{"id":"bxte8kh5enc0","created":1571477376555,"text":"排序","note":"* 有序度，逆序度\n\t* 对于一组数据\n    \t* 排列组合是 n！种\n        \n    * 有序元素\n    \t* 如果i<j ，则a[i] <= a[j]\n        \n    * 有序度\n    \t* 数组中具有有序关系的元素对的个数\n        * 完全有序的，又称满有序度\n        \t* 为：n*(n-1)/2\n            * (n-1)+(n-2)+...+1\n        * 完全逆序的，有序度就是0\n        \n    * 逆序度\n    \t* 逆序度=满有序度-有序度"},"children":[{"data":{"id":"bxtemf23kk80","created":1571478461859,"text":"如何评价、分析一个排序算法","expandState":"collapse"},"children":[{"data":{"id":"bxtemp74gkw0","created":1571478483931,"text":"排序算法的执行效率","note":"* 排序算法的执行效率\n\n\t1. 最好情况、最坏情况、平均情况时间复杂度\n    \t* 要能说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的\n        \n    \t* 有些算法会区分三种复杂度，为了对比，所以最好都做一下区分\n        \n        * 不同有序度的数据，对执行时间肯定有影响\n        \t* 我们要知道排序算法在不同数据下的性能表现\n            \n            \n\t2. 时间复杂度反应的是数据规模n很大的时候的一个增长趋势\n    \t* 实际开发中。数据规模可能并不高\n    \t* 因此在对[同一阶]时间复杂度的排序算法性能对比的时候\n        \t* 我们就要把系数、常数、低阶也考虑进来。\n   \t\n    \n    3. 比较次数和交换（移动）次数\n    \t* 基于比较的排序算法会涉及两种操作\n        \t* 元素比较大小\n            * 元素交换或移动。"},"children":[]},{"data":{"id":"bxten0943ts0","created":1571478507995,"text":"排序算法的内存消耗","note":"* 算法的内存消耗可以通过空间复杂度来衡量\n\n* 原地排序（Sorted in place）\n\t* 特指空间复杂度是O(1)的排序算法"},"children":[]},{"data":{"id":"bxtenme8xaw0","created":1571478556195,"text":"排序算法的稳定性","note":"* 稳定性\n\t* 如果待排序的序列中存在值相等的元素\n    \t* 经过排序之后，相等元素之间原有的先后顺序不变。\n        \n        * 相等元素位置不变就是稳定的排序算法\n        \t* 否则就是不稳定的\n            \n  \n* 应用\n\t* 如实际开发中，先对金额进行排序，再按照创建时间进行排序\n    \t* 方案1 先按照金额排序，对于金额相同的，再进行排序\n        \t* 实现起来复杂\n        \n        * 方案2 先对时间进行排序，再对金额进行排序\n        \t* 使用稳定的排序算法可以非常简洁得实现"},"children":[]}]},{"data":{"id":"bxte9ajleqg0","created":1571477433299,"text":"O(n^2) :冒泡、插入、选择","note":"* 为什么插入排序要比冒泡排序更受欢迎\n\t* 从代码实现上来看\n    \t* 冒泡排序的数据交换要比插入排序的数据移动要复杂\n        * 冒泡排序需要3个赋值操作，而插入排序只需要1个\n        \n        \n* 所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是O(n2)\n\t* 但是如果我们希望把性能优化做到更好，那肯定首选插入排序。\n    * 即考虑算法的系数，低阶等因素","expandState":"collapse"},"children":[{"data":{"id":"bxtiufu5yvs0","created":1571490374909,"text":"冒泡","note":"* 冒泡\n\t* 是原地排序算法\n    \t* 空间复杂度为O(1)\n    \t* 只需要常量级的临时空间(交换时使用)\n        \n    * 是稳定的排序算法\n    \t* 只有交换才会改变前后顺序\n        * 相等并不交换\n        \n        \n    * 时间复杂度\n    \t* 最好O(n)\n        \t* 原本有序\n            \n        * 最坏O(n^2)\n        \t* 原数据逆序 \n            \n        * 平均\n        \t* O(n^2)\n        \t\n\n* 冒泡排序中\n\t* 交换的次数等于逆序度的次数\n    \t* 最坏 n*(n-1)/2,最好 0\n        * 中间值 n*(n-1)/4\n        \n    * 比较操作肯定要比交换操作多\n    \t* 上限O(n^2)\n        * 所以平均时间复杂度是O(n^2)\n        \n    * 这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用\n        \n\n"},"children":[]},{"data":{"id":"bxtjh7rrqhc0","created":1571492159726,"text":"插入","note":"* 元素的移动总次数，也是等于逆序度\n\t* 分成一个有序区间和一个无序区间\n    \t* 每次从无序区间中取出一个元素\n        * 比较找到自己的位置插入\n        \t* 找到自己的位置后，后面的元素全部往后移动一位\n        * 重复N次\n            \n            \n\n* 插入排序\n\t* 是原地排序算法\n    \n\t* 是稳定排序\n    \n    * 时间复杂度\n    \t* 最好情况，已经有序O(n)\n        * 最坏,逆序 O(n^2)\n        \n        * 平均也是O(n^2)\n        \t* 在一个有序的数组中插入一个数字是O(n)\n            * 所以n个就是O(n^2)"},"children":[]},{"data":{"id":"bxtlba2eo140","created":1571497336757,"text":"选择","note":"* 选择排序\n\t* 也分一个有序区间，一个无序区间\n    \n    * 每次从无序区间中选最小的，放进有序区间的末尾\n    \t* 每次通过比较获得未排序的最小元素\n        * 实际操作：将该最小元素与有序与无序的交界处的元素互换位置\n        \n    * 是原地排序\n    \n    * 时间复杂度\n    \t* 最好, 最坏，平均：O(n^2)\n        * 因为即使原本有序，也是每次拿出一个最小的，然后重复N次\n    \n    * [不是]稳定排序\n    \t* 如5，8，5，2，9\n        * 经过一次交换，原本在前的元素5变成后面\n        \t"},"children":[]}]},{"data":{"id":"bxteaa7rw2o0","created":1571477510948,"text":"O(nlogn)：快排、归并","note":"* 都用到了分治思想\n\t* 即将问题拆分成小问题处理\n    \n* 递归\n\t* 递归也是类似的处理方案\n    \n* 因此，分治算法一般都使用递归来实现\n\t* 分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突\n    \n    * 归并、快排的区别\n    \t* 归并是自下而上的排序\n        \t* 先处理子问题，再合并\n            \n        * 快排是自上而下\n        \t* 先分区，再处理子问题\n            \n\n* 使用二分（分治）比冒泡这些快的本质\n\t* 结论上，可通过数学公式的推导\n    * 理解上，冒泡等算法\n    \t* 每一遍的循环，只选出了一个元素，剩余的元素没任何变化\n        * 而两种分治法的排序，每次子问题的处理，或者父问题的处理，是带有一定的有序性\n        \t* 减少下一步的操作","expandState":"expand"},"children":[{"data":{"id":"bxu1ivqj9k00","created":1571543070236,"text":"快排","note":"* 也是使用分治思想\n\n* 数组中选择随机一个元素，例如最后一个\n\t* 作为一个分区点pivot\n    * 遍历p到r之间的数据\n    \t* 将小于pivot的放到左边\n        * 将大于pivot的放到右边\n        * 将pivot放到中间。\n\n* 不断将两边的区间按照此方式处理\n\t* 处理完就是有序的了\n    \n* 将数组分为2个区间\n\t1. 可以使用两个临时数组，实现方便\n    \t* 但是这样就不是原地排序了\n        \n    2. 从左到右遍历数组\n    \t* 标记遇到的第一个比pivot大的元素\n        * 后面遇到比此元素小的，则交换位置\n        \t* 标记元素的角标+1\n            * 新的标记元素肯定也是比pivot元素大的\n        * 最后将标记元素与pviot元素交换\n        \n* 性能分析\n\t* 是原地排序\n    * [不稳定]的算法\n    \t* 因为有交换\n        * 不移动其他元素，直接交换的，都是不稳定的，如选择排序\n        \n    * 时间复杂度\n    \t* 平均O(nlogn)\n        * 极端（原本有序），退化为O(n^2)\n        \t* 原本有序，每次取最后一个元素，则两区间每次都相差很大\n            * 每次都只能处理一个元素\n        * 推理。待树的那一节学习\n        \n    \t\n        \n","expandState":"collapse"},"children":[{"data":{"id":"bxucelqvkao0","created":1571573767241,"text":"应用","note":"* 求无序数组的第K大元素\n\t* 使用快排，定一个中间点pivot\n    \t* 经过一轮比较，k比pivot位置大，则处理右边区间\n        \t* 否则处理左边区间\n        * 直到pivot等于k\n        \t* 则pivot的值就是第k大元素\n            \n    * 此算法复杂度是O(n)\n    \t* 第一次遍历n次\n        * 第二次遍历n/2次...\n        \n        * 等比数列求和\n        \t* 2n-1\n            * 即O(n)\n            \n            \n            \n* 注：等比数列求和公式\n\t* (a1-anq)/(1-q)\n    \t* a1为首项,an为第n项,d为公差,q 为等比"},"children":[]}]},{"data":{"id":"bxu1kf4ssrk0","created":1571543190822,"text":"归并","note":"* 将数组不断分为两半，直至只有一个元素\n\t* 将两半的元素合并，此时这两半数据，内部本身是有序的\n    \t* 对比俩个数组的第一个元素，谁小就取谁，放进临时数组\n        * 处理完后临时数据数据遍历赋值回原数组\n        \n        \n        * 哨兵方式：增加2个子数组的临时数组，大小比子数组大1，用于装哨兵\n        \t* 哨兵放Integer最大值\n            * 先在临时子数组暂存原来子数组数据\n            * 原数组接收对比后的数据\n            * 哨兵的存在可以不用判断是否已经到达边界\n       * 哨兵的代码量会略简洁\n       \n* 性能分析\n\t1. 是稳定的的算法\n    \t* 前提是合并的代码，左边<=右边时，选左边（等于号不能少）\n        \n    2. 时间复杂度\n    \t* 时间复杂度 O(nlogn)\n        * 最好情况、最坏情况，还是平均情况都一样，与数据的有序度无关。非常稳定\n     \n    3. 空间复杂度\n    \t* 需要临时数组\n        * O(n) ,[不是]原地排序","expandState":"expand"},"children":[{"data":{"id":"bxu8on584aw0","created":1571563269488,"text":"时间复杂度分析","note":"* T(n) = 2* T(n/2) + n； \n\t* n>1\n    \t* 后面的n表示合并操作\n        \n\t* T(1) = C；   \n    \t* n=1时，只需要常量级的执行时间，所以表示为C。\n        \n    * 一直推导\n    \t* 2^k * T(n/2^k) + k * n\n        \n        * 当T(n/2^k)=T(1)时\n        \t* n/2^k=1\n            * k=log2n \n        \n        * Cn + n* log2n\n        \t* 即O(nlogn)"},"children":[]}]}]},{"data":{"id":"bxteawan94o0","created":1571477559011,"text":"O(n) : 桶、基数、计数","note":"* 因为时间复杂度是O(n)\n\t* 因此也叫线性排序\n    \n    * 为什么能做到线性排序\n    \t* 不是基于比较的排序算法，不涉及元素之间的比较\n        \t* 基本只需要遍历一次就完成\n     \n    * 对排序的顺序有要求"},"children":[{"data":{"id":"bxudeyc8xy80","created":1571576615765,"text":"桶排序","expandState":"expand","note":"* 将数据分到几个有序的桶中\n\t* 即桶与桶之间是有序的\n    * 对每个桶里的元素进行排序\n    \t* 使用快排\n        * 最后按顺序取出，就是有序的了\n        \n* 时间复杂度\n\t* n个元素，分成m个桶\n    \t* 则每个桶的元素是k=n/m\n        * 每个桶的时间复杂度是O(klogk)\n        \n    * 总复杂度 O(m * klogk)\n    \t* O(n* log n/m)\n        * 当m接近于n时，就是O(n)\n        \n* 使用场景\n\t* 要排序的数据需要很容易就能划分成m个桶\n    * 桶与桶之间有着天然的大小顺序\n    \t* 不需要再次排序\n    * 数据需要均匀\n    \t* 极端情况下，退化为O(nlogn)\n    \n    * 适合用在外部排序中\n    \t* 即数据存储在外部磁盘中，无法将数据全部加载到有限的内存中\n        \n        \n* 例\n\t* 如10G订单信息按照金额排序\n    \t* 如果每个区间数量特别大，则可以对此区间再次细分\n        \n        \n        \n        "},"children":[{"data":{"id":"bxud2o0czmw0","created":1571575652908,"text":"应用","note":"* 现在你有10个接口访问日志文件，每个日志文件大小约300MB\n\t* 每个文件里的日志都是按照时间戳从小到大排序的\n    \t* 你希望将这10个较小的日志文件，合并为1个日志文件\n        * 合并之后的日志仍然按照时间戳从小到大排列。\n        * 如果处理上述排序任务的机器内存只有1GB\n        \n        \n* 每次只读一个接口\n\t* 分到多个桶中\n    * 将桶中进行快排\n        \n    "},"children":[]}]},{"data":{"id":"bxufav466oo0","created":1571581937509,"text":"计数排序","note":"* 计数排序其实是桶排序的一种特殊情况\n\t* 要排序的n个数据，所处的范围并不大的时候，比如最大值是k\n    \t* 就分成N个桶\n        * 桶内元素相等\n        \n        * 例如50w的考生，分数范围是0~900，则分为901个桶\n        \n        \n* 实现\n\t* 使用一个数组C，记录每种元素的个数\n    \t* 便于使用，直接记录小于等于当前元素的总个数\n        \n    *  使用一个数组R，记录有序数组"},"children":[]}]}]}]},"template":"right","theme":"fresh-green","version":"1.4.43"}