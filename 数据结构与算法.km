{"root":{"data":{"id":"bxcash4fucw0","created":1569741132836,"text":"数据结构与算法","note":"1. 广义\n\t* 数据结构\n    \t* 指一组数据的存储结构\n    * 算法\n    \t* 操作数据的一组方法\n\n2. 狭义\n\t* 某些著名的数据结构和算法\n    \t* 比如队列、栈、堆、二分查找、动态规划\n        * 这些都是前人智慧的结晶"},"children":[{"data":{"id":"bxocsqnvixs0","created":1570965515302,"text":"复杂度分析","note":"1. 通过统计，监控等获取算法的执行时间及占用内存\n\t* 叫事后统计法\n    \t* 依赖测试环境，如硬件。还有数据规模等\n    * 因此不准确"},"children":[{"data":{"id":"bxoctcl8pe00","created":1570965563032,"text":"时间复杂度","note":"* 大O时间复杂度\n\t* 表示代码执行时间随数据规模增长的变化趋势\n    * 也叫渐进时间复杂度\n    \t* 简称时间复杂度\n        \n        \n* 时间复杂度分析\n\t* 大O的复杂度表示方法，表示的是一种变化趋势\n    \t* 因此一般会忽略常量、低阶，系数等\n        * 只记录最大阶的量级即可\n        \t* 如循环执行次数最多的一段代码\n            \n        \n        \n* 加法法则\n    * 总复杂度等于量级最大的那段代码的复杂度\n        * 常量级别的代码（与n五无关的），即使执行上万遍，复杂度都是 O(1)\n        * 因为对变化趋势没有影响\n        \n\t* 如代码的复杂度里有O(n),O(n^2)， 则只看最大的O(n^2)\n        \n  \n* 乘法法则\n    * 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n    \t* 如O(n) 与 O(n^2) 的乘积是O(n^3)\n        \n        \n* 多个数据规模, 即数据规模不止一个\n\t* 如 m n\n    \t* 由于两个数字都是变化的\n        * 因此复杂度根据两数据规模一起决定\n        \n        * 如O(m+n) , O(m* n) 等\n   "},"children":[{"data":{"id":"bxodo0eh8a00","created":1570967965791,"text":"复杂度量级","note":"* 多项式量级(按数量级递增)\n\t* 常数阶\n    \t* O(1)\n        * 执行了很多行，只要跟数据规模没关系，就是O(1)\n        \n    * 对数阶\n    \t* O(logn)\n        \n    * 线性阶\n    \t* O(n)\n        \n    * 线性对数阶\n    \t* O(nlogn)\n        \n    * 平方阶，立方阶...k次方阶等\n    \t* O(n^2) O(n^3)\n\n\n\n\n\n\n* 非多项式量级\n\t* O(2^n)和O(n!)\n    \t* 指数阶，阶乘阶\n\n        \n    * 是非常低效的算法\n    \t* 数据规模越来越大时，非多项式量级算法的执行时间会急剧增加"},"children":[]},{"data":{"id":"bxoe1xbbt5s0","created":1570969056168,"text":"对数阶","note":"* O(logn)\n\t* 对数阶的复杂度表示方法中\n    \t* 忽略对数的底\n     \n\t* 因为任何底数的对数\n    \t* 都可以转化为：其他底数的对数 乘以 一个常数\n        * 见有道笔记，此处不好表示底数\n        \n        \n        \n* 对于线性对数阶O(nlogn)\n\t* 相当于O(logn)的代码循环执行了n遍\n    \t* 乘法法则\n        \n    * 归并排序、快速排序的时间复杂度都是O(nlogn)"},"children":[]},{"data":{"id":"bxofdyorb8g0","created":1570972820637,"text":"最好、最坏情况时间复杂度","note":"* 最好\n\t* 在最理想的情况下，执行这段代码的时间复杂度\n \n* 最坏\n\t* 在最糟糕的情况下，执行这段代码的时间复杂度"},"children":[]},{"data":{"id":"bxofe9y9uuw0","created":1570972845157,"text":"平均情况时间复杂度","note":"* 通常是将每种情况的耗时相加\n\t* 除以N种情况的个数\n    \t* 得到一个平均值\n        \n        \n* 但是，不算上各种情况的概率是不准确的\n\t* 因此，应该每种情况单独算上出现的概率\n    \t* 得到加权平均值\n        \n\n* 因此，也叫\n\t* 权平均时间复杂度\n    \t* 或者期望时间复杂度\n   \n   \n   \n* 注\n\t* 一般使用一个复杂度就可以了\n    \n    * 只有同一块代码在不同的情况下，时间复杂度有[量级的差距]\n    \t* 我们才会使用这三种复杂度表示法来区分\n\t"},"children":[]},{"data":{"id":"bxofedd85ls0","created":1570972852591,"text":"均摊时间复杂度","note":"* 相比前面的复杂度分析，使用场景更加特殊、更加有限。\n\n\n* 摊还分析法\n\t* 通过摊还分析得到的时间复杂度\n    \t* 叫均摊时间复杂度\n    \n    * 能够通过摊还分析法处理，就不用使用加权平均去算，会更加简便\n     \n     \n     \n* 使用场景：对于一些特殊的复杂度分析\n\t* 例如，经过n个的O(1) 操作之后\n    \t* 有一个 O(n) 的操作\n    * 并且是有规律的，有一定时序关系的\n    \n    * 则可以将该次O(n) 的操作，均摊到每个O(1)操作\n    \t* 总体复杂度就是O(1)\n      \n      \n      \n* 在能够应用均摊时间复杂度分析的场合\n\t* 一般均摊时间复杂度就等于最好情况时间复杂度\n    \n    * 可以认为\n    \t* 均摊时间复杂度就是一种特殊的平均时间复杂度"},"children":[]}]},{"data":{"id":"bxoctj3oixk0","created":1570965577208,"text":"空间复杂度","note":"* 渐进空间复杂度\n\t* 表示算法的存储空间与数据规模之间的增长关系\n    \n* 常见的空间复杂度就是O(1)、O(n)、O(n^2)  \n\t* 如对于传入的n个参数\n    \t* new对应大小的数组\n        * 则空间复杂度就是O(n)\n    ","layout_right_offset":{"x":-22.499999105930385,"y":95.83332952525899}},"children":[]}]}]},"template":"right","theme":"fresh-green","version":"1.4.43"}