{"root":{"data":{"id":"bxcash4fucw0","created":1569741132836,"text":"数据结构与算法","note":"1. 广义\n\t* 数据结构\n    \t* 指一组数据的存储结构\n    * 算法\n    \t* 操作数据的一组方法\n\n2. 狭义\n\t* 某些著名的数据结构和算法\n    \t* 比如队列、栈、堆、二分查找、动态规划\n        * 这些都是前人智慧的结晶"},"children":[{"data":{"id":"bxocsqnvixs0","created":1570965515302,"text":"复杂度分析","note":"1. 通过统计，监控等获取算法的执行时间及占用内存\n\t* 叫事后统计法\n    \t* 依赖测试环境，如硬件。还有数据规模等\n    * 因此不准确","expandState":"collapse"},"children":[{"data":{"id":"bxoctcl8pe00","created":1570965563032,"text":"时间复杂度","note":"* 大O时间复杂度\n\t* 表示代码执行时间随数据规模增长的变化趋势\n    * 也叫渐进时间复杂度\n    \t* 简称时间复杂度\n        \n        \n* 时间复杂度分析\n\t* 大O的复杂度表示方法，表示的是一种变化趋势\n    \t* 因此一般会忽略常量、低阶，系数等\n        * 只记录最大阶的量级即可\n        \t* 如循环执行次数最多的一段代码\n            \n        \n        \n* 加法法则\n    * 总复杂度等于量级最大的那段代码的复杂度\n        * 常量级别的代码（与n五无关的），即使执行上万遍，复杂度都是 O(1)\n        * 因为对变化趋势没有影响\n        \n\t* 如代码的复杂度里有O(n),O(n^2)， 则只看最大的O(n^2)\n        \n  \n* 乘法法则\n    * 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n    \t* 如O(n) 与 O(n^2) 的乘积是O(n^3)\n        \n        \n* 多个数据规模, 即数据规模不止一个\n\t* 如 m n\n    \t* 由于两个数字都是变化的\n        * 因此复杂度根据两数据规模一起决定\n        \n        * 如O(m+n) , O(m* n) 等\n   "},"children":[{"data":{"id":"bxodo0eh8a00","created":1570967965791,"text":"复杂度量级","note":"* 多项式量级(按数量级递增)\n\t* 常数阶\n    \t* O(1)\n        * 执行了很多行，只要跟数据规模没关系，就是O(1)\n        \n    * 对数阶\n    \t* O(logn)\n        \n    * 线性阶\n    \t* O(n)\n        \n    * 线性对数阶\n    \t* O(nlogn)\n        \n    * 平方阶，立方阶...k次方阶等\n    \t* O(n^2) O(n^3)\n\n\n\n\n\n\n* 非多项式量级\n\t* O(2^n)和O(n!)\n    \t* 指数阶，阶乘阶\n\n        \n    * 是非常低效的算法\n    \t* 数据规模越来越大时，非多项式量级算法的执行时间会急剧增加"},"children":[]},{"data":{"id":"bxoe1xbbt5s0","created":1570969056168,"text":"对数阶","note":"* O(logn)\n\t* 对数阶的复杂度表示方法中\n    \t* 忽略对数的底\n     \n\t* 因为任何底数的对数\n    \t* 都可以转化为：其他底数的对数 乘以 一个常数\n        * 见有道笔记，此处不好表示底数\n        \n        \n        \n* 对于线性对数阶O(nlogn)\n\t* 相当于O(logn)的代码循环执行了n遍\n    \t* 乘法法则\n        \n    * 归并排序、快速排序的时间复杂度都是O(nlogn)"},"children":[]},{"data":{"id":"bxofdyorb8g0","created":1570972820637,"text":"最好、最坏情况时间复杂度","note":"* 最好\n\t* 在最理想的情况下，执行这段代码的时间复杂度\n \n* 最坏\n\t* 在最糟糕的情况下，执行这段代码的时间复杂度"},"children":[]},{"data":{"id":"bxofe9y9uuw0","created":1570972845157,"text":"平均情况时间复杂度","note":"* 通常是将每种情况的耗时相加\n\t* 除以N种情况的个数\n    \t* 得到一个平均值\n        \n        \n* 但是，不算上各种情况的概率是不准确的\n\t* 因此，应该每种情况单独算上出现的概率\n    \t* 得到加权平均值\n        \n\n* 因此，也叫\n\t* 权平均时间复杂度\n    \t* 或者期望时间复杂度\n   \n   \n   \n* 注\n\t* 一般使用一个复杂度就可以了\n    \n    * 只有同一块代码在不同的情况下，时间复杂度有[量级的差距]\n    \t* 我们才会使用这三种复杂度表示法来区分\n\t"},"children":[]},{"data":{"id":"bxofedd85ls0","created":1570972852591,"text":"均摊时间复杂度","note":"* 相比前面的复杂度分析，使用场景更加特殊、更加有限。\n\n\n* 摊还分析法\n\t* 通过摊还分析得到的时间复杂度\n    \t* 叫均摊时间复杂度\n    \n    * 能够通过摊还分析法处理，就不用使用加权平均去算，会更加简便\n     \n     \n     \n* 使用场景：对于一些特殊的复杂度分析\n\t* 例如，经过n个的O(1) 操作之后\n    \t* 有一个 O(n) 的操作\n    * 并且是有规律的，有一定时序关系的\n    \n    * 则可以将该次O(n) 的操作，均摊到每个O(1)操作\n    \t* 总体复杂度就是O(1)\n      \n      \n      \n* 在能够应用均摊时间复杂度分析的场合\n\t* 一般均摊时间复杂度就等于最好情况时间复杂度\n    \n    * 可以认为\n    \t* 均摊时间复杂度就是一种特殊的平均时间复杂度"},"children":[]}]},{"data":{"id":"bxoctj3oixk0","created":1570965577208,"text":"空间复杂度","note":"* 渐进空间复杂度\n\t* 表示算法的存储空间与数据规模之间的增长关系\n    \n* 常见的空间复杂度就是O(1)、O(n)、O(n^2)  \n\t* 如对于传入的n个参数\n    \t* new对应大小的数组\n        * 则空间复杂度就是O(n)\n    ","layout_right_offset":{"x":-22.499999105930385,"y":95.83332952525899}},"children":[]}]},{"data":{"id":"bxp1qn1ya480","created":1571035878465,"text":"数组","note":"* 数组（Array）\n\n1. 是一种线性表 数据结构\n    * 数据排成像一条线一样的结构\n    \n    * 每个线性表上的数据，最多只有前后两个方向\n        * 链表、队列、栈等也是线性表结构\n        * 二叉树、堆、图等是非线性表\n        \n2. 它用一组连续的内存空间，来存储一组具有相同类型的数据。\n\n\n\n","expandState":"collapse"},"children":[{"data":{"id":"bxp20zls5pc0","created":1571036689428,"text":"读","note":"* 数组读比较快\n\t* 是因为数据可以进行随机访问\n    \t* 基于连续的内存空间和相同的数据类型\n        * 首地址 + 角标 * 每个元素大小\n    * 数组支持随机访问，根据下标随机访问的时间复杂度为O(1)\n    \t* 注意不能说数组查找时间复杂度为O(1)\n        \n        \n* 根据寻址公式，所以下标从0开始 更加简便，无需做减1操作\n\t* 角标相当于一个偏移量\n    * 而java等语言沿袭了C语言中的设计，所以下标从0开始\n    \n    \n* 关于二维数组\n\t* 猜测地址是从先按照列，再到行\n    \n    * 对于 m * n 的数组，a [i][j] (i < m,j < n)的地址为：\n\n\t* address = base_address + ( i * n + j) * type_size\n    "},"children":[]},{"data":{"id":"bxp2121igjk0","created":1571036694732,"text":"插入、删除","note":"* 插入\n\t* 随机插进一个数组的一个位置，并且该位置后的元素都往后移动一位\n    \t* 时间复杂度为O(n)\n        * 如插入一个有序结构\n        \n    * 不需要移动\n    \t* 如直接将该位置元素放到最后\n        * 时间复杂度：O(1) \n        * 快排中有使用到这种思想\n        \n        \n        \n* 删除\n\t* 删除数组中随机一个元素，并移动其他元素，保证内存的连续性\n    \t* 时间复杂度：O(n)\n        \n    * 如果不需要保证内存连续性\n    \t* 如只标记为已删除，待空间不够再真正删除\n        * 时间复杂度猜测为O(1)\n        * 与JVM的标记清除算法思想类似"},"children":[]},{"data":{"id":"bxp2lkd4gbs0","created":1571038301900,"text":"与容器比较","note":"* 容器，如ArrayList等\n\t* 优点\n    \t* 可以将很多数组操作的细节封装起来，如：支持动态扩容\n        * ArrayList是按照1.5倍数动态扩容\n        \t* 扩容操作涉及内存申请和数据搬移，如果事先能确定需要存储的数据大小，最好在创建ArrayList的时候事先指定数据大小。\n        \n        \n        \n      \n      \n      \n* 数组使用场景\n    * ArrayList无法存储基本类型，而自动装箱、拆箱有一定的性能消耗\n        * 所以特别关注性能，或者希望使用基本类型，就可以选用数组\n        \n    * 数据大小事先已知，且要做的操作简单,用不到ArrayList的大部分方法\n    \t* 则可以使用数组\n    \n    * 另外多维数组时，Object[][]\n    \t* 看起来更加直观（个人喜好）\n\n\n\n\n* 一般使用容器就足够了，除非想把性能做到极致\n    \t\n        "},"children":[]}]},{"data":{"id":"bxp5b1zpio80","created":1571045941595,"text":"链表","note":"* 对比数组\n\t* 数组需要连续的内存\n\t\t* 链表不需要\n        \n    * 复杂度刚好相反\n    \t* 数组插入O(n),查询O(1)\n        * 链表插入O(1),查询O(n)\n        \n        \n        \n    * 数组实现上使用的是连续的内存空间\n    \t* 可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高\n        \n        * CPU每次从内存读取数据并不是只读取那个特定要访问的地址\n        \t* 而是读取一个数据块\n            * 下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取\n     \n     \n     \n    * 数组扩容，需要将数据重新复制一份。费时","expandState":"collapse"},"children":[{"data":{"id":"bxp5bct6r7s0","created":1571045965145,"text":"关于内存淘汰策略","note":"* 先进先出策略FIFO（First In，First Out）\n\n* 最少使用策略LFU（Least Frequently Used）\n\n* 最近最少使用策略LRU（Least Recently Used）\n\t* linkedHashMap就是利用双向链表来实现的LRU"},"children":[]},{"data":{"id":"bxp5f7ahxbs0","created":1571046266588,"text":"各种链表","note":"\n        \n        \n* 单链表\n\t* 每个链表节点\n    \t* 除存储数据外\n        * 还有一个后继指针next，记录下一个节点的地址\n        \n    * 头结点记录链表的基地址\n    * 尾结点指向空地址null\n    \n    * 删除操作的时间复杂度\n    \t* 不需移动其他节点，因此是O(1)\n    * 查找\n    \t* 无法使用寻址公式\n        * 因此时间复杂度：O(n)\n        \n        \n* 循环链表\n\t* 尾节点的next指向头节点\n    \n* 双向链表\n\t* 除了一个next后继节点\n    \t* 还有一个prev前驱节点\n        \n    * 占用更多空间，但是更加灵活\n    \t* 反正就是可以获取前面的节点，不需要从头开始遍历\n        \n* 双向循环链表\n\t* 如描述，双向，且是环状","layout_right_offset":{"x":8.499997317791099,"y":3.8333333002196355}},"children":[]},{"data":{"id":"bxpc76i3f140","created":1571065385726,"text":"单向链表判断是否回文","note":"1. 使用快慢指针定位链表中间节点\n\t* 快指针一次走两步\n    * 慢指针一次走一步\n    \t* 则快指针走完时，满指针走到中间\n        * 注意判断奇偶数，可根据快指针进行判断\n\n2. 慢指针走的时候，将前半部分反序\n\n3. 前后半部分比较，判断是否为回文\n\n4. 前半部分逆序复原\n\n5. 时间复杂度O(n), 空间复杂度O(1)\n\n* 代码见github"},"children":[]},{"data":{"id":"bxq4lvas1dc0","created":1571145527879,"text":"算法代码技巧","note":"1. 哨兵节点\n\t* 在链表的头部等边界地方，设置哨兵\n    \t* 可以将边界的特殊处理变成普通处理\n        \n    * 如带头链表的头即为哨兵 \n    \t* 则所有节点的插入删除逻辑都一样了\n        \n    * 又如：在数组中找值为x的节点\n    \t* 先判断数组尾部的的是否符合\n        * 不符合的话，替换尾部节点为目标x\n        \t* 符合直接返回\n        * 从头开始遍历数组，直至找到x\n        \t* x不是最后一个，则找到\n          \t* x是最后一个，表示数组中没这个元素\n        \n        * 优化点：无需判断数组是否角标越界。直接判断是否等于x即可\n        \t* 大数据量中，少一个判断也是很重要的\n            * 当然平时不要这样写。。。\n   \t"},"children":[]}]},{"data":{"id":"bxremdslruw0","created":1571275339195,"text":"栈","note":"* 栈是一种 操作受限 的线性表\n\t* 先进后出，后进先出\n    \t* 只允许一端插入、删除数据\n        \n        \n* 相比链表、数组，栈带来的只有限制\n\t* 但是在特定场景，栈能够满足需求\n    \t* 同时更加可控，不容易出错\n        \n      \n* 数组实现的栈\t\n\t* 叫：顺序栈\n\n* 链表实现的栈\t\n\t* 叫：链式栈\n    \n    \n    \n* 栈 操作的时间、空间复杂度\n\t* 时间复杂度\n    \t* O(1) 因为每次都只操作顶部的一个元素\n    \n    * 空间复杂度\n    \t* O(1) 只需一两个临时变量存储空间\n        * 动态扩容的顺序栈，到达某一临界大小时扩容，迁移数据到更大的内存\n        \t* 此时可用摊还分析法，将数据搬移工作均摊到每一次入栈操作\n            * 时间复杂度还是O(1)\n\n\n* 注意：\n\t* 存储的空间都是一个大小为n的数组或链表，不代表空间复杂度就是O(n)\n        * 因为这个空间是必须的，无法省掉\n        * 我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间","expandState":"collapse"},"children":[{"data":{"id":"bxrf07ku5pk0","created":1571276422763,"text":"栈的应用","note":"1. 函数调用栈\n\t* 每进入一个函数\n    \t* 就会将临时变量作为一个栈帧入栈\n    * 当被调用函数执行完成，返回之后\n    \t* 将这个函数对应的栈帧出栈\n        \n\n2. 表达式\n\t* 传入一串表达式，如:3+ 5* 4-2\n    * 编译器通过两个栈实现\n    \t* 一个保存操作数的栈\n        * 一个是保存运算符的栈\n        \n    * 从左往右遍历表达式\n    \t* 遇到数字，压入操作数栈\n        * 遇到运算符\n        \t* 与运算符栈顶的元素比较\n    * 比较规则\n    \t* 先确定所有的优先级\n        * 当前比运算符栈顶的元素优先级高，压入栈顶\n        * 等级更低或者等级相同，取出栈顶运算符先运算\n        \n        \n        \n3. 检查各种括号()[]{}等是否匹配\n    * 遍历表达式。遇到坐括号就压入栈中\n    \t* 遇到右括号就取出栈顶元素进行匹配\n        * 全部能匹配则通过\n        \n\n4. 浏览器的前进后退\n\t* 使用2个栈\n    \t* 点后退，就将左栈栈顶页面移到右栈\n        * 点前进，就将右栈栈顶元素移到左栈\n        * 点了其他页面，清空右栈\n    \n"},"children":[]}]},{"data":{"id":"bxrfxglglm00","created":1571279028409,"text":"队列","note":"* 也是操作受限的线性表数据结构\n\t* 先进先出\n    \n* 数组实现的队列\n\t* 顺序队列\n    \n* 链表实现的队列\n\t* 链式队列"},"children":[]}]},"template":"right","theme":"fresh-green","version":"1.4.43"}